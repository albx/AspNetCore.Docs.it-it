---
title: Eseguire la migrazione da ASP.NET Core 2,2 a 3,0
author: rick-anderson
description: Informazioni su come eseguire la migrazione di un progetto ASP.NET Core 2,2 ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/24/2019
uid: migration/22-to-30
ms.openlocfilehash: 57df37322d2aadad5a48345158aef26cde0edda3
ms.sourcegitcommit: 8a36be1bfee02eba3b07b7a86085ec25c38bae6b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/24/2019
ms.locfileid: "71219149"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Eseguire la migrazione da ASP.NET Core 2,2 a 3,0

Di [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Questo articolo illustra come aggiornare un progetto di ASP.NET Core 2,2 esistente a ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prerequisiti

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio per Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Aggiornare il file di progetto

### <a name="update-the-target-framework"></a>Aggiornare il Framework di destinazione

L'esecuzione di ASP.NET Core 3.0 e versioni successive sarà consentita solo in .NET Core. Impostare il [moniker del Framework di destinazione (TFM)](/dotnet/standard/frameworks) su `netcoreapp3.0`:

```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Rimuovi riferimenti ai pacchetti obsoleti

ASP.NET Core non produce più un numero elevato di funzionalità dei pacchetti NuGet. Questi riferimenti ai pacchetti devono essere rimossi dal file di progetto. Per visualizzare l'elenco completo dei pacchetti non più prodotti, vedere di seguito:

<details>
    <summary>Fare clic qui per espandere l'elenco dei pacchetti che non vengono più prodotti</summary>

    * Microsoft.AspNetCore
    * Microsoft.AspNetCore.All
    * Microsoft.AspNetCore.App
    * Microsoft. AspNetCore. antifalsificazione
    * Microsoft. AspNetCore. Authentication
    * Microsoft. AspNetCore. Authentication. abstracts
    * Microsoft. AspNetCore. Authentication. cookies
    * Microsoft. AspNetCore. Authentication. Core
    * Microsoft. AspNetCore. Authentication. JwtBearer
    * Microsoft. AspNetCore. Authentication. OAuth
    * Microsoft. AspNetCore. Authentication. OpenIdConnect
    * Microsoft. AspNetCore. Authorization
    * Microsoft. AspNetCore. Authorization. Policy
    * Microsoft. AspNetCore. CookiePolicy
    * Microsoft. AspNetCore. CORS
    * Microsoft. AspNetCore. Cryptography. Internal
    * Microsoft. AspNetCore. Cryptography. Derivation
    * Microsoft.AspNetCore.DataProtection
    * Microsoft. AspNetCore. dataprotection. abstracts
    * Microsoft. AspNetCore. dataprotection. Extensions
    * Microsoft. AspNetCore. Diagnostics
    * Microsoft. AspNetCore. Diagnostics. HealthChecks
    * Microsoft.AspNetCore.HostFiltering
    * Microsoft.AspNetCore.Hosting
    * Microsoft. AspNetCore. Hosting. abstracts
    * Microsoft. AspNetCore. Hosting. Server. abstracts
    * Microsoft. AspNetCore. http
    * Microsoft. AspNetCore. http. abstracts
    * Microsoft. AspNetCore. http. Connections
    * Microsoft. AspNetCore. http. Extensions
    * Microsoft. AspNetCore. http. Features
    * Microsoft. AspNetCore. HttpOverrides
    * Microsoft. AspNetCore. HttpsPolicy
    * Microsoft. AspNetCore. Identity
    * Microsoft. AspNetCore. Localization
    * Microsoft. AspNetCore. Localization. Routing
    * Microsoft. AspNetCore. MiddlewareAnalysis
    * Microsoft.AspNetCore.Mvc
    * Microsoft. AspNetCore. Mvc. abstracts
    * Microsoft. AspNetCore. Mvc. Analyzers
    * Microsoft. AspNetCore. Mvc. ApiExplorer
    * Microsoft. AspNetCore. Mvc. API. Analyzers
    * Microsoft. AspNetCore. Mvc. Core
    * Microsoft. AspNetCore. Mvc. CORS
    * Microsoft. AspNetCore. Mvc. DataAnnotations
    * Microsoft. AspNetCore. Mvc. Formatters. JSON
    * Microsoft. AspNetCore. Mvc. Formatters. XML
    * Microsoft. AspNetCore. Mvc. Localization
    * Microsoft.AspNetCore.Mvc.Razor
    * Microsoft. AspNetCore. Mvc. Razor. Extensions
    * Microsoft. AspNetCore. Mvc. Razor. ViewCompilation
    * Microsoft. AspNetCore. Mvc. RazorPages
    * Microsoft. AspNetCore. Mvc. TagHelpers
    * Microsoft. AspNetCore. Mvc. ViewFeatures
    * Microsoft. AspNetCore. Razor
    * Microsoft. AspNetCore. Razor. Runtime
    * Microsoft. AspNetCore. Razor. Design
    * Microsoft. AspNetCore. ResponseCaching
    * Microsoft. AspNetCore. ResponseCaching. abstracts
    * Microsoft. AspNetCore. ResponseCompression
    * Microsoft. AspNetCore. Rewrite
    * Microsoft.AspNetCore.Routing
    * Microsoft. AspNetCore. Routing. abstracts
    * Microsoft. AspNetCore. Server. HttpSys
    * Microsoft. AspNetCore. Server. IIS
    * Microsoft. AspNetCore. Server. IISIntegration
    * Microsoft. AspNetCore. Server. gheppio
    * Microsoft. AspNetCore. Server. gheppio. Core
    * Microsoft. AspNetCore. Server. gheppio. https
    * Microsoft. AspNetCore. Server. gheppio. Transport. abstracts
    * Microsoft. AspNetCore. Server. gheppio. Transport. Sockets
    * Microsoft. AspNetCore. Session
    * Microsoft. AspNetCore. SignalR
    * Microsoft. AspNetCore. SignalR. Core
    * Microsoft.AspNetCore.StaticFiles
    * Microsoft. AspNetCore. WebSockets
    * Microsoft. AspNetCore. webutilities
    * Microsoft.Net. http. Headers</details>

### <a name="framework-reference"></a>Riferimento a Framework

Le `Microsoft.AspNetCore.App` funzionalità di ASP.net core disponibili tramite uno dei pacchetti elencati in precedenza sono disponibili come parte del Framework condiviso.  Il *Framework condiviso* è il set di assembly (file con*estensione dll* ) installato nel computer e include un componente di runtime e un Targeting Pack. Per altre informazioni, vedere [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Il framework condiviso).


* I progetti destinati all' `Microsoft.NET.Sdk.Web` SDK fanno riferimento in modo `Microsoft.AspNetCore.App` implicito al Framework.

Per questi progetti non sono necessari riferimenti aggiuntivi:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* I progetti destinati `Microsoft.NET.Sdk` a `Microsoft.NET.Sdk.Razor` o SDK devono aggiungere un esplicito `Microsoft.AspNetCore.App` `FrameworkReference` a:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

### <a name="add-package-references-for-removed-assemblies"></a>Aggiungere i riferimenti al pacchetto per gli assembly rimossi

ASP.NET Core 3,0 rimuove alcuni assembly che in precedenza facevano parte `Microsoft.AspNetCore.App` del riferimento al pacchetto. Per continuare a utilizzare le funzionalità fornite da questi assembly, fare riferimento alle versioni 3,0 dei pacchetti corrispondenti:

* Per ulteriori informazioni https://docs.microsoft.com/ef/core/providers/index su come fare riferimento al pacchetto specifico del provider di database, vedere Entity Framework Core.

* Il supporto dell'interfaccia utente Identity per l' [interfaccia utente Identity](xref:security/authentication/identity) può essere aggiunto facendo riferimento al pacchetto [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Servizi SPA
    * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
    * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Autenticazione: il supporto per i flussi di autenticazione di terze parti è disponibile come pacchetto NuGet:

    * [OAuth di Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook)
    * [Google OAuth](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google)
    * [bearer token OpenID Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer)
    * [Autenticazione dell'account Microsoft](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount)
    * [Autenticazione di OpenID Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect)
    * [OAuth Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter)
    * [Autenticazione di WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation)

* Formattazione e supporto per la negoziazione `System.Net.HttpClient` del contenuto per il pacchetto NuGet [Microsoft. AspNet. WebAPI. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) fornisce un' `System.Net.HttpClient` estendibilità utile a `ReadAsAsync`con `PostJsonAsync` API come e così via.

* Compilazione del runtime Razor: il supporto per la compilazione in fase di esecuzione di visualizzazioni e pagine Razor fa ora parte di [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Supporto `Newtonsoft.Json` MVC: il supporto per l'uso `Newtonsoft.Json` di MVC con fa ora parte di [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

### <a name="analyzer-support"></a>Supporto analizzatore

* I progetti destinati `Microsoft.NET.Sdk.Web` agli analizzatori di riferimento implicito sono stati forniti in precedenza come parte del pacchetto [Microsoft. AspNetCore. Mvc. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Per abilitare queste informazioni non sono necessari altri riferimenti.

* Se l'applicazione usa gli [analizzatori di API](xref:web-api/advanced/analyzers) forniti in precedenza usando il pacchetto [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , modificare il file di progetto in modo che faccia riferimento agli analizzatori forniti come parte di .NET Core Web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
  </PropertyGroup>

  ...
</Project>
```

### <a name="razor-class-library"></a>Libreria di classi Razor

I progetti della libreria di classi Razor che forniscono componenti dell'interfaccia utente `AddRazorSupportForMvc` per MVC devono impostare la proprietà nel file di progetto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modello di hosting in-process

* Per impostazione predefinita, i progetti sono [basati sul modello di hosting in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3,0 o versione successiva. Se il valore è `<AspNetCoreHostingModel>` `InProcess`, è possibile rimuovere facoltativamente la proprietà nel file di progetto.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configurazione

Eseguire la migrazione della configurazione di Gheppio al generatore host `ConfigureWebHostDefaults` Web fornito da (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se l'applicazione crea manualmente l'host con `HostBuilder`, chiamare `UseKestrel` sul generatore host Web in `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Il middleware della connessione sostituisce le schede di connessione

Gli adattatori<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>di connessione () sono stati rimossi da gheppio. Sostituire gli adapter di connessione con il middleware di connessione. Il middleware di connessione è simile al middleware HTTP nella pipeline ASP.NET Core ma per le connessioni di livello inferiore. HTTPS e registrazione connessione:

* Sono stati spostati dagli adattatori di connessione al middleware di connessione.
* Questi metodi di estensione funzionano come nelle versioni precedenti di ASP.NET Core. 

Per altre informazioni, vedere [l'esempio TlsFilterConnectionHandler nella sezione ListenOptions. Protocols dell'articolo di Gheppio](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Astrazioni del trasporto spostate e rese pubbliche

Il livello trasporto gheppio è stato esposto come interfaccia pubblica in `Connections.Abstractions`. Come parte di questi aggiornamenti:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`e i tipi associati sono stati rimossi.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>è stato spostato <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> da alle opzioni di trasporto.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>è stato rimosso <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>da.

Per altre informazioni, vedere le risorse di GitHub seguenti:

* [Astrazioni di rete client/server (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementare la nuova astrazione del listener del fondamento e riposizionare il gheppio in alto (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Intestazioni del trailer della richiesta gheppio

Per le app destinate a versioni precedenti di ASP.NET Core:

* Gheppio aggiunge intestazioni di trailer in blocchi HTTP/1.1 nella raccolta delle intestazioni della richiesta.
* I trailer sono disponibili dopo la lettura del corpo della richiesta fino alla fine.

Questo causa alcune problematiche relative all'ambiguità tra intestazioni e trailer, quindi i trailer sono stati spostati in una nuova raccolta (`RequestTrailerExtensions`) in 3,0.

I trailer della richiesta HTTP/2 sono:

* Non disponibile in ASP.NET Core 2,2.
* Disponibile in 3,0 come `RequestTrailerExtensions`.

Sono presenti nuovi metodi di estensione della richiesta per accedere a questi trailer. Come per HTTP/1.1, i trailer sono disponibili dopo la lettura del corpo della richiesta fino alla fine.

Per la versione 3,0 sono disponibili i `RequestTrailerExtensions` metodi seguenti:

* `GetDeclaredTrailers`Ottiene l'intestazione `Trailer` della richiesta che elenca i trailer da prevedere dopo il corpo. &ndash;
* `SupportsTrailers`&ndash; Indica se la richiesta supporta la ricezione di intestazioni trailer.
* `CheckTrailersAvailable`&ndash; Controlla se la richiesta supporta i trailer e se è disponibile per la lettura. Questo controllo non presuppone che siano presenti trailer da leggere. Non è possibile leggere i trailer anche se `true` viene restituito da questo metodo.
* `GetTrailer`&ndash; Ottiene l'intestazione finale richiesta dalla risposta. Verificare `SupportsTrailers` prima di `GetTrailer`chiamare oppure <xref:System.NotSupportedException> può verificarsi se la richiesta non supporta le intestazioni finali.

Per ulteriori informazioni, vedere [put trailer request in una raccolta separata (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO disabilitato

`AllowSynchronousIO`Abilita o Disabilita le API di i/o sincrono `HttpRequest.Body.Read`, `HttpResponse.Body.Write`ad esempio `Stream.Flush`, e. Queste API sono un'origine di inedia dei thread che causa arresti anomali dell'app. In 3,0 `AllowSynchronousIO` è disabilitato per impostazione predefinita. Per altre informazioni, vedere [la sezione i/o sincrona nell'articolo di Gheppio](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Oltre ad abilitare `AllowSynchronousIO` le opzioni `ConfigureKestrel`di con, l'i/o sincrono può essere sottoposto a override in base alle singole richieste come mitigazione temporanea:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se si riscontrano problemi <xref:System.IO.TextWriter> con le implementazioni o altri flussi che chiamano API sincrone in [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), chiamare invece la nuova <xref:System.IO.Stream.DisposeAsync*> API.

Per ulteriori informazioni, vedere [[annuncio] AllowSynchronousIO disabilitato in tutti i server (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. gheppio. https rimosso

In ASP.NET Core 2,1, il contenuto di *Microsoft. AspNetCore. Server. gheppio. HTTPS. dll* è stato spostato in *Microsoft. AspNetCore. Server. gheppio. Core. dll*. Si tratta di un aggiornamento senza interruzioni `TypeForwardedTo` che utilizza gli attributi. Per 3,0, l'assembly vuoto *Microsoft. AspNetCore. Server. gheppio. HTTPS. dll* (e il pacchetto NuGet) sono stati rimossi.

Le librerie che fanno riferimento a [Microsoft. AspNetCore. Server. gheppio. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devono aggiornare ASP.NET Core dipendenze a 2,1 o versione successiva.

Le app e le librerie destinate a ASP.NET Core 2,1 o versioni successive dovrebbero rimuovere tutti i riferimenti diretti al pacchetto [Microsoft. AspNetCore. Server. gheppio. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Supporto di Json.NET

Come parte del lavoro per [migliorare il Framework condiviso ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) è stato rimosso dal framework ASP.NET Core Shared.

Il valore predefinito per ASP.NET Core è ora [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), che è una novità di .net core 3,0. Si consiglia `System.Text.Json` di utilizzare quando possibile. Si tratta di prestazioni elevate e non richiede una dipendenza della libreria aggiuntiva. Tuttavia, poiché `System.Text.Json` è nuovo, è possibile che al momento non siano presenti funzionalità richieste dall'app.

L'app può richiedere `Netwtonsoft.Json` l'integrazione se usa `Newtonsoft.Json`funzionalità specifiche di, ad esempio JsonPatch o convertitori o se [Formatta](xref:web-api/advanced/formatting) `Newtonsoft.Json`tipi specifici.

Per usare Json.NET in un progetto SignalR di ASP.NET Core 3,0, vedere [passare a Newtonsoft. JSON](#switch-to-newtonsoftjson) in questo documento.

Per usare Json.NET in un progetto ASP.NET Core 3,0:

* Aggiungere un riferimento al pacchetto a [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aggiornamento `Startup.ConfigureServices` da chiamare `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`è compatibile con i nuovi metodi di registrazione del servizio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Le impostazioni di Json.NET possono essere impostate nella chiamata `AddNewtonsoftJson`a:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registrazione del servizio MVC

ASP.NET Core 3,0 aggiunge nuove opzioni per la registrazione di scenari MVC `Startup.ConfigureServices`all'interno di.

Sono disponibili tre nuovi metodi di estensione di primo livello correlati a `IServiceCollection` scenari MVC in. I modelli utilizzano questi nuovi metodi anziché `UseMvc`. Tuttavia, `AddMvc` continua a comportarsi come nelle versioni precedenti.

Nell'esempio seguente viene aggiunto il supporto per i controller e le funzionalità relative alle API, ma non viste o pagine. Il modello API usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Nell'esempio seguente viene aggiunto il supporto per i controller, le funzionalità correlate all'API e le visualizzazioni, ma non le pagine. Il modello di applicazione Web (MVC) utilizza questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Nell'esempio seguente viene aggiunto il supporto per Razor Pages e il supporto minimo del controller. Il modello di applicazione Web usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

I nuovi metodi possono anche essere combinati. L'esempio seguente equivale a chiamare `AddMvc` in ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing del codice di avvio

Se un'app chiama `UseMvc` o `UseSignalR`, eseguire la migrazione dell'app al [routing dell'endpoint](xref:fundamentals/routing) , se possibile. Per migliorare la compatibilità del routing degli endpoint con le versioni precedenti di MVC, sono state ripristinate alcune delle modifiche apportate alla generazione di URL introdotte in ASP.NET Core 2,2. Se si sono verificati problemi durante l'uso del routing degli endpoint in 2,2, è previsto un miglioramento in ASP.NET Core 3,0 con le eccezioni seguenti:

* Se l'app implementa `IRouter` o eredita da `Route`, usare [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) come sostituzione.

* Se l'app accede `RouteData.Routers` direttamente all'interno di MVC per analizzare gli URL, è possibile sostituirla con l'uso di. `LinkParser.ParsePathByEndpointName` 
 * Definire la route con un nome di route.
 * Usare `LinkParser.ParsePathByEndpointName` e passare il nome della route desiderata.

Il routing degli endpoint supporta la stessa sintassi del modello di route e le funzionalità `IRouter`di creazione di modelli di route di. Il routing degli `IRouteConstraint`endpoint supporta. Il routing degli `[Route]`endpoint `[HttpGet]`supporta, e gli altri attributi di routing MVC.

Per la maggior parte delle `Startup` applicazioni, è necessario apportare solo modifiche.

### <a name="migrate-startupconfigure"></a>Esegui la migrazione di startup. Configure

Consigli generali:

* Aggiungi `UseRouting`.
* Se l'app chiama `UseStaticFiles`, inserire `UseStaticFiles` **before** `UseRouting`.
* Se l'app usa funzionalità di autenticazione/autorizzazione come `AuthorizePage` o `[Authorize]`, inserire la chiamata a `UseAuthentication` e `UseAuthorization` **after** `UseRouting` (e **dopo** `UseCors` se viene usato il middleware CORS).
* Sostituire `UseMvc` o `UseSignalR` con .`UseEndpoints`
* Se l'app usa scenari [CORS](xref:security/cors) `[EnableCors]`, ad esempio, inserire la chiamata a prima di `UseCors` qualsiasi altro middleware che usa CORS (ad esempio, `UseCors` inserire `UseAuthentication`prima `UseAuthorization`di, `UseEndpoints`e).
* Sostituire `IHostingEnvironment` `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> con `IWebHostEnvironment` e aggiungere un'istruzione per lo spazio dei nomi.
* Sostituire `IApplicationLifetime` con <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> spazio dei nomi).
* Sostituire `EnvironmentName` con <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> spazio dei nomi).

Il codice seguente è un esempio di `Startup.Configure` in una tipica app ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Dopo l'aggiornamento del `Startup.Configure` codice precedente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Per la maggior parte delle applicazioni `UseAuthentication`, `UseAuthorization`le chiamate `UseCors` a, e devono essere visualizzate `UseRouting` tra `UseEndpoints` le chiamate a e per essere effettive.
### <a name="health-checks"></a>Controlli di integrità

I controlli di integrità usano il routing degli endpoint con l'host generico. In `Startup.Configure`, chiamare `MapHealthChecks` sul generatore di endpoint con l'URL dell'endpoint o il percorso relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Gli endpoint di controllo integrità possono:

* Specificare uno o più host o porte consentiti.
* Richiedere l'autorizzazione.
* Richiede CORS.

Per altre informazioni, vedere <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Guida del middleware di sicurezza

Il supporto per l'autorizzazione e CORS è unificato intorno all'approccio [middleware](xref:fundamentals/middleware/index) . In questo modo è possibile usare lo stesso middleware e le stesse funzionalità in questi scenari. In questa versione è disponibile un middleware di autorizzazione aggiornato e il middleware CORS è stato migliorato in modo da poter comprendere gli attributi usati dai controller MVC.

#### <a name="cors"></a>CORS

In precedenza, CORS potrebbe essere difficile da configurare. Il middleware è stato fornito per alcuni casi d'uso, ma i filtri MVC erano destinati a essere usati **senza** il middleware in altri casi d'uso. Con ASP.NET Core 3,0, è consigliabile che tutte le app che richiedono CORS usino il middleware CORS in tandem con il routing degli endpoint. `UseCors`può essere fornito con un criterio predefinito, mentre `[EnableCors]` gli `[DisableCors]` attributi e possono essere utilizzati per eseguire l'override dei criteri predefiniti laddove necessario.

Nell'esempio seguente:

* CORS è abilitato per tutti gli endpoint con il `default` criterio denominato.
* La `MyController` classe Disabilita cors con l' `[DisableCors]` attributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizzazione

Nelle versioni precedenti di ASP.NET Core, il supporto dell'autorizzazione è stato `[Authorize]` fornito tramite l'attributo. Il middleware di autorizzazione non era disponibile. In ASP.NET Core 3,0 è necessario il middleware di autorizzazione. Si consiglia di inserire il middleware di autorizzazione`UseAuthorization`ASP.NET Core () `UseAuthentication`subito dopo. Il middleware di autorizzazione può essere configurato anche con criteri predefiniti, che possono essere sottoposti a override.

In ASP.NET Core 3,0 o versione successiva `UseAuthorization` , viene chiamato `Startup.Configure`in e per quanto `HomeController` segue è necessario un utente connesso:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Se l'app usa un `AuthorizeFilter` come filtro globale in MVC, è consigliabile effettuare il refactoring del codice per fornire un criterio nella chiamata a `AddAuthorization`.

Inizialmente `DefaultPolicy` è configurato per richiedere l'autenticazione, pertanto non è necessaria alcuna configurazione aggiuntiva. Nell'esempio seguente gli endpoint MVC sono contrassegnati come in `RequireAuthorization` modo che tutte le richieste devono essere autorizzate in base `DefaultPolicy`a. Tuttavia, `HomeController` consente l'accesso senza che l'utente acceda all'app a `[AllowAnonymous]`causa di:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

È anche possibile personalizzare i criteri. Basandosi sull'esempio precedente, `DefaultPolicy` è configurato per richiedere l'autenticazione e un ambito specifico:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

In alternativa, tutti gli endpoint possono essere configurati in modo `[Authorize]` da `RequireAuthorization` richiedere l'autorizzazione `FallbackPolicy`senza o configurando un. `FallbackPolicy` È diverso `DefaultPolicy`da. Il `DefaultPolicy` viene attivato da `[Authorize]` o `RequireAuthorization`, mentre l'oggetto `FallbackPolicy` viene attivato quando non è impostato alcun altro criterio. `FallbackPolicy`Inizialmente è configurato per consentire le richieste senza autorizzazione.

L'esempio seguente è identico a quello dell' `DefaultPolicy` esempio precedente, ma `FallbackPolicy` USA per richiedere sempre l'autenticazione su tutti gli endpoint `[AllowAnonymous]` tranne quando è specificato:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L'autorizzazione da parte del middleware funziona senza il Framework con una conoscenza specifica dell'autorizzazione. Ad esempio, i [controlli di integrità](xref:host-and-deploy/health-checks) non hanno una conoscenza specifica dell'autorizzazione, ma i controlli di integrità possono avere un criterio di autorizzazione configurabile applicato dal middleware.

Ogni endpoint può inoltre personalizzare i requisiti di autorizzazione. `UseAuthorization` Nell'esempio seguente, elabora l'autorizzazione `DefaultPolicy`con, ma l' `/healthz` endpoint di controllo integrità richiede un `admin` utente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protezione viene implementata per alcuni scenari. `UseEndpoint`il middleware genera un'eccezione se un criterio di autorizzazione o di CORS viene ignorato a causa del middleware mancante. È in corso il supporto dell'analizzatore per fornire commenti e suggerimenti aggiuntivi sulla configurazione errata.

### <a name="signalr"></a>SignalR

Il mapping degli hub SignalR si verifica ora `UseEndpoints`all'interno di.

Eseguire il mapping di `MapHub`ogni hub con. Come nelle versioni precedenti, ogni hub è elencato in modo esplicito.

Nell'esempio seguente viene aggiunto il supporto per `ChatHub` l'hub SignalR:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

È disponibile una nuova opzione per controllare i limiti delle dimensioni dei messaggi dai client. Ad esempio, in `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.NET Core 2,2, è possibile impostare `TransportMaxBufferSize` e che consentono di controllare in modo efficace le dimensioni massime del messaggio. In ASP.NET Core 3,0 questa opzione consente ora di controllare solo le dimensioni massime prima che venga osservato il backpressure.

### <a name="mvc-controllers"></a>Controller MVC

Il mapping dei controller si verifica ora `UseEndpoints`all'interno di.

Aggiungere `MapControllers` se l'app usa il routing degli attributi. Poiché il routing include il supporto per molti Framework in ASP.NET Core 3,0 o versione successiva, l'aggiunta di controller indirizzati agli attributi è il consenso esplicito.

Sostituire quanto segue:

* `MapRoute`con`MapControllerRoute`
* `MapAreaRoute`con`MapAreaControllerRoute`

Poiché il routing include ora il supporto per più di MVC, la terminologia è stata modificata in modo da rendere questi metodi chiaramente quelli che eseguono. Le route convenzionali, `MapControllerRoute` ad esempio, / / `MapAreaControllerRoute` vengonoapplicatenell'ordineincuisonostateaggiunte.`MapDefaultControllerRoute` Posizionare prima le route più specifiche, ad esempio le route per un'area.

Nell'esempio seguente:

* `MapControllers`aggiunge il supporto per i controller indirizzati all'attributo.
* `MapAreaControllerRoute`aggiunge una route convenzionale per i controller in un'area.
* `MapControllerRoute`aggiunge una route convenzionale per i controller.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor Pages

Il mapping Razor Pages ora avviene all' `UseEndpoints`interno di.

Aggiungere `MapRazorPages` se l'app usa Razor Pages. Poiché il routing degli endpoint include il supporto per molti Framework, l'aggiunta di Razor Pages è ora il consenso esplicito.

Nell'esempio seguente, `MapRazorPages` aggiunge il supporto per Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usare MVC senza routing degli endpoint

Per usare MVC `UseMvc` tramite `UseMvcWithDefaultRoute` o in ASP.NET Core 3,0 è necessario un consenso esplicito `Startup.ConfigureServices`all'interno di. Questa operazione è necessaria perché MVC deve sapere se può basarsi sul middleware Authorization e CORS durante l'inizializzazione. Viene fornito un analizzatore che avvisa se l'app tenta di usare una configurazione non supportata.

Se l'app richiede il `IRouter` supporto legacy, `EnableEndpointRouting` disabilitare usando uno degli approcci seguenti in `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Controlli di integrità

I controlli di integrità possono essere usati come *router-Ware* con il routing degli endpoint.

Aggiungere `MapHealthChecks` per utilizzare i controlli di integrità con il routing degli endpoint. Il `MapHealthChecks` metodo accetta argomenti simili a `UseHealthChecks`. Il vantaggio di usare `MapHealthChecks` over `UseHealthChecks` è la possibilità di applicare l'autorizzazione e di avere un controllo più granulare sui criteri di corrispondenza.

Nell'esempio `MapHealthChecks` seguente viene chiamato per un endpoint di controllo integrità in `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder sostituisce WebHostBuilder

I modelli di ASP.NET Core 3,0 usano un [host generico](xref:fundamentals/host/generic-host). Le versioni precedenti usavano il [Web host](xref:fundamentals/host/web-host). Il codice seguente illustra la classe generata `Program` dal modello di ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Il codice seguente illustra la classe generata `Program` dal modello di ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>rimane in 3,0 e è il tipo di `webBuilder` visualizzato nell'esempio di codice precedente. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>verrà deprecato in una versione futura e sostituito da `HostBuilder`.

La modifica più significativa da `WebHostBuilder` a `HostBuilder` è nell' [inserimento delle dipendenze (di)](xref:fundamentals/dependency-injection). Quando si `HostBuilder`USA, è possibile inserire <xref:Microsoft.Extensions.Configuration.IConfiguration> solo <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> il `Startup`costruttore e in. Vincoli `HostBuilder` di di:

* Consente la compilazione del contenitore DI INSERIMENTO DI una sola volta.
* Evita i problemi di durata degli oggetti risultanti, ad esempio la risoluzione di più istanze di singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization spostato in un assembly diverso

Il ASP.NET Core 2,2 e i `AddAuthorization` metodi inferiori in *Microsoft. AspNetCore. Authorization. dll*:

* Sono stati rinominati `AddAuthorizationCore`.
* Sono state spostate in *Microsoft. AspNetCore. Authorization. Policy. dll*.

Le app che usano sia *Microsoft. AspNetCore. Authorization. dll* che *Microsoft. AspNetCore. Authorization. Policy. dll* non hanno alcun effetto.

Le app che non usano *Microsoft. AspNetCore. Authorization. Policy. dll* devono eseguire una delle operazioni seguenti:

* Passa a utilizzando`AddAuthorizationCore`
* Aggiungere un riferimento a *Microsoft. AspNetCore. Authorization. Policy. dll*.

Per ulteriori informazioni, vedere [Overload Change in `AddAuthorization(o =>`) si trova in un assembly diverso #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Codice SignalR

Il client JavaScript SignalR è stato modificato `@aspnet/signalr` da `@microsoft/signalr`a. Per rispondere a questa modifica, modificare i riferimenti in file *Package. JSON* , istruzioni require e istruzioni Import ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON è il protocollo predefinito

`System.Text.Json`è ora il protocollo dell'Hub predefinito usato dal client e dal server.

In `Startup.ConfigureServices`, chiamare `AddJsonProtocol` per impostare le opzioni del serializzatore.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Client:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Passa a Newtonsoft. JSON

Se si usano funzionalità di `Newtonsoft.Json` che non sono supportate in `System.Text.Json`, è possibile tornare a: `Newtonsoft.Json`

1. Installare il pacchetto NuGet [Microsoft. AspNetCore. SignalR. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Nel client, concatenare `AddNewtonsoftJsonProtocol` una chiamata `HubConnectionBuilder` al metodo all'istanza:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Nel server, concatenare `AddNewtonsoftJsonProtocol` una chiamata `AddSignalR` al metodo alla chiamata al `Startup.ConfigureServices`metodo in:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Acconsenti esplicitamente alla compilazione del runtime

In 3,0, la compilazione in fase di esecuzione è uno scenario di consenso esplicito. Per abilitare la compilazione in fase <xref:mvc/views/view-compilation#runtime-compilation>di esecuzione, vedere.

## <a name="migrating-libraries-via-multi-targeting"></a>Migrazione di librerie tramite la funzionalità multitargeting

Le librerie spesso devono supportare più versioni di ASP.NET Core. La maggior parte delle librerie compilate con versioni precedenti di ASP.NET Core dovrebbe continuare a funzionare senza problemi. Le condizioni seguenti richiedono che l'app venga compilata in modo incrociato:

* La libreria si basa su una funzionalità con una modifica di [rilievo](#breaking-api-changes)binaria.
* La libreria desidera sfruttare le nuove funzionalità di ASP.NET Core 3,0. 

Ad esempio:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Usare `#ifdefs` per illuminare ASP.NET Core 3,0 API specifiche:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Modifiche delle API di rilievo

Per ulteriori modifiche di rilievo nella versione ASP.NET Core 3,0, vedere il [repository ASPNET/annunci](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0). Per un riepilogo delle modifiche di rilievo da 2,2 a 3,0 in .NET Core, ASP.NET Core e Entity Framework Core, vedere [modifiche di rilievo per la migrazione dalla versione 2,2 alla versione 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 non è attualmente disponibile per app Azure servizio. 

Ci auguriamo che questa operazione sarà presto disponibile. Fino a quando non è disponibile ASP.NET Core 3,0 nel servizio app Azure, seguire le istruzioni in [distribuire ASP.NET Core versione di anteprima per app Azure servizio](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
