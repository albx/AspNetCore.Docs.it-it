---
title: Eseguire la migrazione da ASP.NET Core 2,2 a 3,0 Preview
author: rick-anderson
description: Informazioni su come eseguire la migrazione di un progetto ASP.NET Core 2,2 ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/03/2019
uid: migration/22-to-30
ms.openlocfilehash: c53357f1cebad1e148925052c84bc3b3d8de4d8b
ms.sourcegitcommit: e6bd2bbe5683e9a7dbbc2f2eab644986e6dc8a87
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/03/2019
ms.locfileid: "70238106"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Eseguire la migrazione da ASP.NET Core 2,2 a 3,0

Di [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Questo articolo illustra come aggiornare un progetto di ASP.NET Core 2,2 esistente a ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prerequisiti

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio per Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Aggiornare il file di progetto

* Impostare il [moniker del Framework di destinazione (TFM)](/dotnet/standard/frameworks) su `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Rimuovere Any `<PackageReference>` nel metapacchetto [Microsoft. AspNetCore. All](xref:fundamentals/metapackage) o [Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app) .

* Rimuovere Any `<PackageReference>` nel pacchetto [Microsoft. AspNetCore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Se l'applicazione usa gli [analizzatori di API](xref:web-api/advanced/analyzers), `<PackageReference>` rimuovere qualsiasi elemento per il pacchetto [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) . Modificare il file di progetto per usare l'analizzatore fornito come parte del .NET Core SDK:

```xml
<PropertyGroup>
 <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
</PropertyGroup>
```

* Aggiornare l' `Version` attributo sugli elementi `<PackageReference>` rimanenti `Microsoft.AspNetCore.*` per i pacchetti nell'anteprima corrente (ad esempio `3.0.0-preview5-19227-01`,).

  Se non è presente alcuna versione 3,0 di un pacchetto, il pacchetto potrebbe essere stato deprecato in 3,0. Molti di questi pacchetti fanno parte di `Microsoft.AspNetCore.App` e non è necessario farvi riferimento singolarmente. Per un elenco preliminare dei pacchetti non più prodotti in 3,0, vedere [interrompere la produzione di pacchetti per assembly di Framework condivisi in 3,0 (ASPNET/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). Il *Framework condiviso* è il set di assembly (file con*estensione dll* ) installati nel computer e a `Microsoft.AspNetCore.App`cui fa riferimento. Per altre informazioni, vedere [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Il framework condiviso).

* Gli assembly per diversi componenti rilevanti sono stati rimossi `Microsoft.AspNetCore.App` da in 3,0. Aggiungere `<PackageReference>` elementi se si usano API dei pacchetti elencati in [assembly rimossi da Microsoft. AspNetCore. app 3,0 (ASPNET/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Esempi di componenti rimossi includono:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  L'elenco di assembly di cui `Microsoft.AspNetCore.App` è in fase di spedizione non è stato finalizzato e cambierà prima della 3,0 RTM.

  Esaminare il codice seguente:

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  Il `ReadAsAsync` metodo chiamato nel codice precedente è incluso in `Microsoft.AspNet.WebApi.Client`. Installare il pacchetto NuGet [Microsoft. AspNet. WebAPI. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) per risolvere il problema di compilazione in 3,0.

* Aggiungere il [supporto per JSON.NET](#jsonnet-support).

* Per impostazione predefinita, i progetti sono [basati sul modello di hosting in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3,0 o versione successiva. Se il valore è `<AspNetCoreHostingModel>` `InProcess`, è possibile rimuovere facoltativamente la proprietà nel file di progetto.

## <a name="jsonnet-support"></a>Supporto di Json.NET

Come parte del lavoro per [migliorare il Framework condiviso ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) è stato rimosso dal framework ASP.NET Core Shared.

Per usare Json.NET in un progetto ASP.NET Core 3,0:

* Aggiungere un riferimento al pacchetto a [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aggiornamento `Startup.ConfigureServices` da chiamare `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```
  
  `AddNewtonsoftJson`è compatibile con i nuovi metodi di registrazione del servizio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Le impostazioni di Json.NET possono essere impostate nella chiamata `AddNewtonsoftJson`a:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registrazione del servizio MVC

ASP.NET Core 3,0 aggiunge nuove opzioni per la registrazione di scenari MVC `Startup.ConfigureServices`all'interno di.

Sono disponibili tre nuovi metodi di estensione di primo livello correlati a `IServiceCollection` scenari MVC in. I modelli utilizzano questi nuovi metodi anziché `UseMvc`. Tuttavia, `AddMvc` continua a comportarsi come nelle versioni precedenti.

Nell'esempio seguente viene aggiunto il supporto per i controller e le funzionalità relative alle API, ma non viste o pagine. Il modello API usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Nell'esempio seguente viene aggiunto il supporto per i controller, le funzionalità correlate all'API e le visualizzazioni, ma non le pagine. Il modello di applicazione Web (MVC) utilizza questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Nell'esempio seguente viene aggiunto il supporto per Razor Pages e il supporto minimo del controller. Il modello di applicazione Web usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

I nuovi metodi possono anche essere combinati. L'esempio seguente equivale a chiamare `AddMvc` in ASP.NET Core 2,2: 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Aggiornare il codice di avvio del routing

Se un'app chiama `UseMvc` o `UseSignalR`, eseguire la migrazione dell'app al [routing dell'endpoint](xref:fundamentals/routing) , se possibile. Per migliorare la compatibilità del routing degli endpoint con le versioni precedenti di MVC, sono state ripristinate alcune delle modifiche apportate alla generazione di URL introdotte in ASP.NET Core 2,2. Se si sono verificati problemi durante l'uso del routing degli endpoint in 2,2, è previsto un miglioramento in ASP.NET Core 3,0 con le eccezioni seguenti:

* Se l'app implementa `IRouter` o eredita da `Route`, è possibile evitare di eseguire la migrazione in questo momento. Fornire commenti [e suggerimenti per pianificare la migrazione di implementazioni basate su IRouter nel routing degli endpoint](https://github.com/aspnet/AspNetCore/issues/4221).

* Se l'app accede `RouteData.Routers` direttamente all'interno di MVC, è consigliabile evitare di eseguire la migrazione in questo momento. Fornire commenti e suggerimenti sulle [indicazioni per la migrazione per l'uso di RouteData. router](https://github.com/aspnet/AspNetCore/issues/9148).

Il routing degli endpoint supporta la stessa sintassi del modello di route e le funzionalità `IRouter`di creazione di modelli di route di. Il routing degli `IRouteContraint`endpoint supporta. Il routing degli `[Route]`endpoint `[HttpGet]`supporta, e gli altri attributi di routing MVC.

Per la maggior parte delle `Startup` applicazioni, è necessario apportare solo modifiche.

### <a name="migrate-startupconfigure"></a>Esegui la migrazione di startup. Configure

Consigli generali:

* Aggiungi `UseRouting`. 
* Se l'app chiama `UseStaticFiles`, inserire `UseStaticFiles` **before** `UseRouting`.
* Se l'app usa funzionalità di autenticazione/autorizzazione come `AuthorizePage` o `[Authorize]`, inserire la chiamata a `UseAuthentication` e `UseAuthorization` **after** `UseRouting` (e **dopo** `UseCors` se viene usato il middleware CORS).
* Sostituire `UseMvc` o `UseSignalR` con .`UseEndpoints`
* Se l'app usa scenari [CORS](xref:security/cors) `[EnableCors]`, ad esempio, inserire la chiamata a prima di `UseCors` qualsiasi altro middleware che usa CORS (ad esempio, inserire `UseCors` prima `UseAuthentication`di `UseAuthorization`, e `UseMvc`).
* Sostituire `IHostingEnvironment` `using` `Microsoft.Extensions.Hosting` con `IWebHostEnvironment` e aggiungere un'istruzione per lo spazio dei nomi.

Di seguito è riportato un esempio `Startup.Configure` di in una tipica app ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Dopo l'aggiornamento del `Startup.Configure` codice precedente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Guida del middleware di sicurezza

Il supporto per l'autorizzazione e CORS è unificato intorno all'approccio [middleware](xref:fundamentals/middleware/index) . In questo modo è possibile usare lo stesso middleware e le stesse funzionalità in questi scenari. In questa versione è disponibile un middleware di autorizzazione aggiornato e il middleware CORS è stato migliorato in modo da poter comprendere gli attributi usati dai controller MVC.

#### <a name="cors"></a>CORS

In precedenza, CORS potrebbe essere difficile da configurare. Il middleware è stato fornito per alcuni casi d'uso, ma i filtri MVC erano destinati a essere usati **senza** il middleware in altri casi d'uso. Con ASP.NET Core 3,0, è consigliabile che tutte le app che richiedono CORS usino il middleware CORS in tandem con il routing degli endpoint. `UseCors`può essere fornito con un criterio predefinito, mentre `[EnableCors]` gli `[DisableCors]` attributi e possono essere utilizzati per eseguire l'override dei criteri predefiniti laddove necessario. 

Nell'esempio seguente:

* CORS è abilitato per tutti gli endpoint con il `default` criterio denominato.
* La `MyController` classe Disabilita cors con l' `[DisableCors]` attributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

Nelle versioni precedenti di ASP.NET Core, il supporto dell'autorizzazione è stato `[Authorize]` fornito tramite l'attributo. Il middleware di autorizzazione non era disponibile. In ASP.NET Core 3,0 è necessario il middleware di autorizzazione. Si consiglia di inserire il middleware di autorizzazione`UseAuthorization`ASP.NET Core () `UseAuthentication`subito dopo. Il middleware di autorizzazione può essere configurato anche con criteri predefiniti, che possono essere sottoposti a override.

In ASP.NET Core 3,0 o versione successiva `UseAuthorization` , viene chiamato `Startup.Configure`in e per quanto `HomeController` segue è necessario un utente connesso:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Se l'app usa un `AuthorizeFilter` come filtro globale in MVC, è consigliabile effettuare il refactoring del codice per fornire un criterio nella chiamata a `AddAuthorization`.

Inizialmente `DefaultPolicy` è configurato per richiedere l'autenticazione, pertanto non è necessaria alcuna configurazione aggiuntiva. Nell'esempio seguente gli endpoint MVC sono contrassegnati come in `RequireAuthorization` modo che tutte le richieste devono essere autorizzate in base `DefaultPolicy`a. Tuttavia, `HomeController` consente l'accesso senza che l'utente acceda all'app a `[AllowAnonymous]`causa di:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

È anche possibile personalizzare i criteri. Basandosi sull'esempio precedente, `DefaultPolicy` è configurato per richiedere l'autenticazione e un ambito specifico:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...
    
    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

In alternativa, tutti gli endpoint possono essere configurati in modo `[Authorize]` da `RequireAuthorization` richiedere l'autorizzazione `FallbackPolicy`senza o configurando un. `FallbackPolicy` È diverso `DefaultPolicy`da. Il `DefaultPolicy` viene attivato da `[Authorize]` o `RequireAuthorization`, mentre l'oggetto `FallbackPolicy` viene attivato quando non è impostato alcun altro criterio. `FallbackPolicy`Inizialmente è configurato per consentire le richieste senza autorizzazione.

L'esempio seguente è identico a quello dell' `DefaultPolicy` esempio precedente, ma `FallbackPolicy` USA per richiedere sempre l'autenticazione su tutti gli endpoint `[AllowAnonymous]` tranne quando è specificato:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...
    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L'autorizzazione da parte del middleware funziona senza il Framework con una conoscenza specifica dell'autorizzazione. Ad esempio, i [controlli di integrità](xref:host-and-deploy/health-checks) non hanno una conoscenza specifica dell'autorizzazione, ma i controlli di integrità possono avere un criterio di autorizzazione configurabile applicato dal middleware.

Ogni endpoint può inoltre personalizzare i requisiti di autorizzazione. `UseAuthorization` Nell'esempio seguente, elabora l'autorizzazione `DefaultPolicy`con, ma l' `/healthz` endpoint di controllo integrità richiede un `admin` utente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protezione viene implementata per alcuni scenari. `UseEndpoint`il middleware genera un'eccezione se un criterio di autorizzazione o di CORS viene ignorato a causa del middleware mancante. È in corso il supporto dell'analizzatore per fornire commenti e suggerimenti aggiuntivi sulla configurazione errata.

### <a name="migrate-signalr"></a>Migrare SignalR

Il mapping degli hub SignalR si verifica ora `UseEndpoints`all'interno di. 

Eseguire il mapping di `MapHub`ogni hub con. Come nelle versioni precedenti, ogni hub è elencato in modo esplicito.

Nell'esempio seguente viene aggiunto il supporto per `ChatHub` l'hub SignalR:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>Migrare controller MVC

Il mapping dei controller si verifica ora `UseEndpoints`all'interno di. 

Aggiungere `MapControllers` se l'app usa il routing degli attributi. Poiché il routing include il supporto per molti Framework in ASP.NET Core 3,0 o versione successiva, l'aggiunta di controller indirizzati agli attributi è il consenso esplicito. 

Sostituire quanto segue:

* `MapRoute`con`MapControllerRoute`
* `MapAreaRoute`con`MapAreaControllerRoute`

Poiché il routing include ora il supporto per più di MVC, la terminologia è stata modificata in modo da rendere questi metodi chiaramente quelli che eseguono. Le route convenzionali, `MapControllerRoute` ad esempio, / / `MapAreaControllerRoute` vengonoapplicatenell'ordineincuisonostateaggiunte.`MapDefaultControllerRoute` Posizionare prima le route più specifiche, ad esempio le route per un'area.

Nell'esempio seguente:

* `MapControllers`aggiunge il supporto per i controller indirizzati all'attributo.
* `MapAreaControllerRoute`aggiunge una route convenzionale per i controller in un'area.
* `MapControllerRoute`aggiunge una route convenzionale per i controller.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Esegui migrazione Razor Pages

Il mapping Razor Pages ora avviene all' `UseEndpoints`interno di.

Aggiungere `MapRazorPages` se l'app usa Razor Pages. Poiché il routing degli endpoint include il supporto per molti Framework, l'aggiunta di Razor Pages è ora il consenso esplicito.

Nell'esempio seguente, `MapRazorPages` aggiunge il supporto per Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usare MVC senza routing degli endpoint

Per usare MVC `UseMvc` tramite `UseMvcWithDefaultRoute` o in ASP.NET Core 3,0 è necessario un consenso esplicito `Startup.ConfigureServices`all'interno di. Questa operazione è necessaria perché MVC deve sapere se può basarsi sul middleware Authorization e CORS durante l'inizializzazione. Viene fornito un analizzatore che avvisa se l'app tenta di usare una configurazione non supportata.

Se l'app richiede il `IRouter` supporto legacy, `EnableEndpointRouting` disabilitare usando uno degli approcci seguenti in `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Eseguire la migrazione dei controlli di integrità

I controlli di integrità possono essere usati come *router-Ware* con il routing degli endpoint.

Aggiungere `MapHealthChecks` per utilizzare i controlli di integrità con il routing degli endpoint. Il `MapHealthChecks` metodo accetta argomenti simili a `UseHealthChecks`. Il vantaggio di usare `MapHealthChecks` over `UseHealthChecks` è la possibilità di applicare l'autorizzazione e di avere un controllo più granulare sui criteri di corrispondenza. 

Nell'esempio `MapHealthChecks` seguente viene chiamato per un endpoint di controllo integrità in `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder sostituisce WebHostBuilder

I modelli di ASP.NET Core 3,0 usano un [host generico](xref:fundamentals/host/generic-host). Le versioni precedenti usavano il [Web host](xref:fundamentals/host/web-host). Il codice seguente illustra la classe generata `Program` dal modello di ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Il codice seguente illustra la classe generata `Program` dal modello di ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>rimane in 3,0 e è il tipo di `webBuilder` visualizzato nell'esempio di codice precedente. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>verrà deprecato in una versione futura e sostituito da `HostBuilder`.

La modifica più significativa da `WebHostBuilder` a `HostBuilder` è nell' [inserimento delle dipendenze (di)](xref:fundamentals/dependency-injection). Quando si `HostBuilder`USA, è possibile inserire <xref:Microsoft.Extensions.Configuration.IConfiguration> solo <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> il `Startup`costruttore e in. Vincoli `HostBuilder` di di:

* Consente la compilazione del contenitore DI INSERIMENTO DI una sola volta.
* Evita i problemi di durata degli oggetti risultanti, ad esempio la risoluzione di più istanze di singleton.

## <a name="update-signalr-code"></a>Aggiornare il codice SignalR

`System.Text.Json`è ora il protocollo dell'Hub predefinito usato dal client e dal server.

In `Startup.ConfigureServices`, chiamare `AddJsonProtocol` per impostare le opzioni del serializzatore.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Client:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Passa a Newtonsoft. JSON

Se si usano funzionalità di `Newtonsoft.Json` che non sono supportate in `System.Text.Json`, è possibile tornare a: `Newtonsoft.Json`

1. Installare il pacchetto NuGet [Microsoft. AspNetCore. SignalR. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Nel client, concatenare `AddNewtonsoftJsonProtocol` una chiamata `HubConnectionBuilder` al metodo all'istanza:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Nel server, concatenare `AddNewtonsoftJsonProtocol` una chiamata `AddSignalR` al metodo alla chiamata al `Startup.ConfigureServices`metodo in:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Acconsenti esplicitamente alla compilazione del runtime

In 3,0, la compilazione in fase di esecuzione è uno scenario di consenso esplicito. Per abilitare la compilazione in fase https://docs.microsoft.com/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0#runtime-compilation di esecuzione, vedere.
