---
title: Eseguire la migrazione da ASP.NET Core 2.2 a 3.0 Preview
author: tdykstra
description: Informazioni su come eseguire la migrazione di un progetto ASP.NET Core 2.2 in ASP.NET Core 3.0.
ms.author: tdykstra
ms.custom: mvc
ms.date: 04/17/2019
uid: migration/22-to-30
ms.openlocfilehash: 59e8fc4da0d2ce5a2a3ab9e4141b84af0da4b771
ms.sourcegitcommit: eb784a68219b4829d8e50c8a334c38d4b94e0cfa
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/22/2019
ms.locfileid: "59982907"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Eseguire la migrazione da ASP.NET Core 2.2 a 3.0

Dal [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Questo articolo illustra come aggiornare un progetto ASP.NET Core 2.2 esistente a ASP.NET Core 3.0.

[!INCLUDE[](~/includes/net-core-prereqs-all-3.0.md)]

## <a name="update-the-project-file"></a>Aggiornare il file di progetto

* Impostare il [Target Framework Moniker (TFM)](/dotnet/standard/frameworks#referring-to-frameworks) a `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Rimuovere eventuali `<PackageReference>` per il [Microsoft. aspnetcore](xref:fundamentals/metapackage) oppure [Microsoft.AspNetCore.App](xref:fundamentals/metapackage-app) metapacchetto.

* Aggiornamento di `Version` su rimanenti `<PackageReference>` elementi per `Microsoft.AspNetCore.*` pacchetti per l'anteprima corrente (ad esempio, `3.0.0-preview-18579-0053`).

  Se è presente alcuna versione 3.0 di un pacchetto, il pacchetto potrebbe essere stato deprecato nella versione 3.0. Molti di questi fanno parte di `Microsoft.AspNetCore.App` e non deve essere specificato singolarmente. Per un elenco preliminare dei pacchetti non più prodotti in 3.0, vedere [arrestare la produzione di pacchetti per gli assembly di framework condiviso nella versione 3.0 (aspnet/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756).

* Alcuni assembly sono stati rimossi da `Microsoft.AspNetCore.App` tra 2.x e 3.0. Potrebbe essere necessario aggiungere `<PackageReference>` elementi se si usano le API da pacchetti elencati nel [gli assembly da rimuovere da 3.0 Microsoft.AspNetCore.App (aspnet/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Ad esempio, `Microsoft.EntityFrameworkCore` e `System.Data.SqlClient` non fanno parte di `Microsoft.AspNetCore.App`. L'elenco degli assembly di spedizione `Microsoft.AspNetCore.App` non è ancora stata finalizzata ancora e cambierà prima 3.0 RTM.

* Aggiungere [Json.NET supporto](#jsonnet-support).

* Per impostazione predefinita i progetti di [modello di hosting in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3.0 o versione successiva. È eventualmente possibile rimuovere il `<AspNetCoreHostingModel>` proprietà nel file di progetto se il valore è `InProcess`.

## <a name="jsonnet-support"></a>Supporto di Json.NET

Come parte del lavoro [migliorare il framework di ASP.NET Core condiviso](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) è stato rimosso dal framework condiviso ASP.NET Core.

Per usare Json.NET in un progetto ASP.NET Core 3.0:

* Aggiungere un riferimento al pacchetto [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Update `Startup.ConfigureServices` chiamare `AddNewtonsoftJson()`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  Newtonsoft impostazioni possono essere impostate con `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registrazione del servizio MVC

ASP.NET Core 3.0 aggiunge nuove opzioni per la registrazione di scenari MVC all'interno di `Startup.ConfigureServices`.

Tre nuovi metodi di estensione di primo livello relativa agli scenari di MVC su `IServiceCollection` sono disponibili. I modelli usano questi nuovi metodi anziché `UseMvc`. Tuttavia, `AddMvc` continua a comportarsi come ha nelle versioni precedenti.

Nell'esempio seguente aggiunge il supporto per controller e funzionalità API, ma non a viste o le pagine. Il modello API Usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Nell'esempio seguente aggiunge il supporto per controller, funzionalità correlate a API e le viste, ma non le pagine. Il modello di applicazione Web (MVC) Usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Nell'esempio seguente aggiunge il supporto per le pagine Razor e supporto del controller minimo. Il modello di applicazione Web Usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

I nuovi metodi possono anche essere combinati. L'esempio seguente è equivalente alla chiamata `AddMvc` in ASP.NET Core 2.2: 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Aggiornare il codice di avvio routing

Se un'app per le chiamate `UseMvc` oppure `UseSignalR`, eseguire la migrazione all'app di [Endpoint di Routing](xref:fundamentals/routing) se possibile. Per migliorare la compatibilità di Routing a Endpoint con le versioni precedenti di MVC, è stata ripristinata alcune delle modifiche nella generazione di URL introdotta in ASP.NET Core 2.2. Se si sono verificati problemi con il Routing Endpoint 2.2, prevedono miglioramenti nella versione 3.0 di ASP.NET Core con le eccezioni seguenti:

* Se l'app implementi `IRouter` o eredita da `Route`, è possibile evitare di eseguire la migrazione in questo momento. Fornire commenti e suggerimenti alla [intende eseguire la migrazione di implementazioni IRouter basati su Endpoint di Routing](https://github.com/aspnet/AspNetCore/issues/4221).

* Se l'app accede direttamente a `RouteData.Routers` all'interno di MVC, è possibile evitare la migrazione in questo momento. Fornire commenti e suggerimenti alla [materiale sussidiario di migrazione per l'uso di RouteData.Routers](https://github.com/aspnet/AspNetCore/issues/9148).

Routing a endpoint supporta la stessa sintassi di modello di route e il modello di route come funzionalità per la creazione `IRouter`. Endpoint Routing supporta `IRouteContraint`. Routing supporta l'endpoint `[Route]`, `[HttpGet]`e gli altri attributi di routing MVC.

Per la maggior parte delle applicazioni, solo `Startup` saranno necessarie modifiche.

### <a name="migrate-startupconfigure"></a>Eseguire la migrazione di Startup. Configure

Consiglio generico:

* Aggiungere `UseRouting`. 
* Se l'app chiama `UseStaticFiles`, inserire `UseStaticFiles` **prima** `UseRouting`.
* Se l'app Usa le funzionalità di autenticazione/autorizzazione, ad esempio `AuthorizePage` oppure `[Authorize]`, inserire la chiamata a `UseAuthentication` e `UseAuthorization` **dopo** `UseRouting`.
* Se l'app Usa [CORS](xref:security/cors) funzionalità, ad esempio `[EnableCors]`, posizionare `UseCors` successivo.
* Sostituire `UseMvc` oppure `UseSignalR` con `UseEndpoints`.

Di seguito è riportato un esempio di `Startup.Configure` in un'app ASP.NET Core 2.2 tipica:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Dopo l'aggiornamento precedente `Startup.Configure` codice:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();
    app.UseCors();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Materiale sussidiario di middleware di sicurezza

Supporto per CORS e l'autorizzazione è unificato tutto il [middleware](xref:fundamentals/middleware/index) approccio. Ciò consente l'uso delle stesso middleware e funzionalità in questi scenari. In questa versione viene fornito un middleware autorizzazione aggiornato e middleware CORS è stato migliorato in modo che sia in grado di utilizzare gli attributi utilizzati dai controller MVC.

#### <a name="cors"></a>CORS

In precedenza, CORS può essere difficile da configurare. Middleware è stato specificato per l'uso in alcuni casi d'uso, ma filtri MVC sono stati possono essere utilizzati **senza** il middleware in altri casi d'uso. Con ASP.NET Core 3.0, è consigliabile che tutte le app che richiedono CORS usare il middleware CORS in abbinamento con l'Endpoint di Routing. `UseCors` può essere fornito con un criterio predefinito, e `[EnableCors]` e `[DisableCors]` attributi possono essere utilizzati per sostituire i criteri predefiniti ove necessario. 

Nell'esempio seguente:

* CORS è abilitato per tutti gli endpoint con il `default` denominato criterio.
* Il `MyController` classe Disabilita CORS con la `[DisableCors]` attributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizzazione

Nelle versioni precedenti di ASP.NET Core, supporto per l'autorizzazione è stato fornito tramite il `[Authorize]` attributo. Middleware di autorizzazione non era disponibile. In ASP.NET Core 3.0, il middleware di autorizzazione è necessario. È consigliabile posizionare il middleware di autorizzazione (`UseAuthentication`) immediatamente prima `UseAuthorization`. Autorizzazione middleware può anche essere configurato con un criterio predefinito, che può essere sottoposto a override.

In ASP.NET Core 3.0 o versione successiva `UseAuthorization` viene chiamato nel `Startup.Configure`e le seguenti `HomeController` richiede un oggetto firmato nell'utente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Se l'app Usa un' `AuthorizeFilter` come filtro globale in MVC, si consiglia di refactoring del codice per fornire un criterio per il `UseAuthorization` middleware.

Nell'esempio seguente, un criterio personalizzato da applicare a tutte le richieste quando `UseAuthorization` viene chiamato e il `HomeController` consente l'accesso senza che l'utente l'accesso nell'app:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L'autorizzazione dal middleware funziona senza il framework abbiano alcuna consapevolezza specifica di autorizzazione. Ad esempio, [controlli di integrità](xref:host-and-deploy/health-checks) non dispone di alcuna conoscenza diretta di autorizzazione, ma i controlli di integrità possono avere un criterio di autorizzazione configurabile dal middleware.

Nell'esempio seguente `UseAuthorization` elabora l'autorizzazione senza un criterio predefinito, ma la `/healthz` endpoint di controllo di integrità richiede che l'utente sia nel `admin` ruolo: 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Protezione dati viene implementato per alcuni scenari. `UseEndpoint` middleware genera un'eccezione se un'autorizzazione o un criterio CORS viene ignorata a causa di un middleware mancano. Supporto di analizzatore per fornire commenti e suggerimenti aggiuntivi sull'errore di configurazione sono in corso.

### <a name="migrate-signalr"></a>Eseguire la migrazione di SignalR

Mapping degli hub SignalR ora ha luogo all'interno `UseEndpoints`. 

Eseguire il mapping di ogni hub con `MapHub`. Come nelle versioni precedenti, ogni hub è elencato in modo esplicito.

Nell'esempio seguente, il supporto per il `ChatHub` hub SignalR viene aggiunto:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>Eseguire la migrazione di controller MVC

Mapping dei controller ora ha luogo all'interno `UseEndpoints`. 

Aggiungere `MapControllers` se l'app Usa il routing con attributi. Poiché routing include il supporto per molti framework di ASP.NET Core 3.0 o versione successiva, l'aggiunta di attributi di routing controller è fornire il consenso esplicito. 

Sostituire gli elementi seguenti:

* `MapRoute` con `MapControllerRoute`
* `MapAreaRoute` con `MapAreaControllerRoute`

Poiché routing ora include il supporto per più di MVC, la terminologia è stato modificato affinché chiaramente indicato cosa fanno questi metodi. Le route convenzionali, ad esempio `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` vengono applicate nell'ordine che vengono aggiunti. Inserisci prima le route più specifiche (ad esempio, le route per un'area).

Nell'esempio seguente:

* `MapControllers` Aggiunge il supporto per i controller di attributi di routing.
* `MapAreaControllerRoute` Aggiunge una route convenzionale per i controller in un'area.
* `MapControllerRoute` Aggiunge una route convenzionale per i controller.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Eseguire la migrazione di pagine Razor

Mapping di Razor Pages ora ha luogo all'interno `UseEndpoints`.

Aggiungere `MapRazorPages` se l'app Usa le pagine Razor. Poiché l'Endpoint di Routing include il supporto per diversi Framework, l'aggiunta di che Razor Pages è a questo punto fornire il consenso esplicito.

Nell'esempio seguente, `MapRazorPages` aggiunge il supporto per le pagine Razor:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usare MVC senza l'Endpoint di Routing

Usa MVC tramite `UseMvc` oppure `UseMvcWithDefaultRoute` in ASP.NET Core 3.0 richiede l'impostazione esplicita acconsentire esplicitamente all'interno di `Startup.ConfigureServices`. Ciò è necessario perché MVC devono sapere che è possibile fare affidamento su richieste di autorizzazione e middleware CORS durante l'inizializzazione. Un analizzatore viene specificato che visualizza un avviso se l'app prova a usare una configurazione non supportata.

Se l'app richiede legacy `IRouter` supportare, disabilitare `EnableEndpointRouting` usando uno dei seguenti approcci `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Eseguire la migrazione di controlli di integrità

Controlli di integrità possono essere utilizzati come un *router-ware* con Endpoint di Routing.

Aggiungere `MapHealthChecks` usare integrità verifica con l'Endpoint di Routing. Il `MapHealthChecks` metodo accetta argomenti simili a `UseHealthChecks`. Il vantaggio dell'utilizzo `MapHealthChecks` failover `UseHealthChecks` è la possibilità di applicare l'autorizzazione e per avere maggiore controllo con granularità fine tramite i criteri di corrispondenza. 

Nell'esempio riportato di seguito `MapHealthChecks` viene chiamato per un endpoint di controllo di integrità in `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder sostituisce WebHostBuilder

Usano i modelli ASP.NET Core 3.0 [Host generico](xref:fundamentals/host/generic-host). Le versioni precedenti utilizzate [Web Host](xref:fundamentals/host/web-host). Il codice seguente illustra il modello di ASP.NET Core 3.0 generato `Program` classe:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Il codice seguente illustra la 2.2 di ASP.NET Core generati da un modello `Program` classe:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> rimane nella versione 3.0 ed è il tipo del `webBuilder` illustrato nell'esempio di codice precedente. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> sarà deprecata in una versione futura e sostituito da `HostBuilder`.

Il cambiamento più significativo dal `WebHostBuilder` a `HostBuilder` le novità [inserimento (dipendenze)](xref:fundamentals/dependency-injection). Quando si usa `HostBuilder`, è possibile solo inserire <xref:Microsoft.Extensions.Configuration.IConfiguration> e <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> in `Startup`del costruttore. Il `HostBuilder` vincoli l'inserimento delle dipendenze:

* Abilitare il contenitore di inserimento delle dipendenze per la compilazione solo una volta.
* Consente di evitare i problemi di durata degli oggetti risultante, ad esempio la risoluzione di più istanze di singleton.

## <a name="update-signalr-code"></a>Aggiornare il codice di SignalR

Se si chiama `AddJsonProtocol`, sostituirlo con `AddNewtonsoftJsonProtocol`.

* Gli esempi seguenti illustrano il codice lato server prima e dopo la modifica:

  ```csharp
  services.AddSignalR(...)
          .AddJsonProtocol(...) // 2.2
  ```

  ```csharp
  services.AddSignalR(...)
          .AddNewtonsoftJsonProtocol(...) // 3.0
  ```

* Gli esempi seguenti illustrano il codice client .NET di prima e dopo la modifica:

  ```csharp
  connection = new HubConnectionBuilder()
      .WithUrl(...)
      .AddJsonProtocol(...) // 2.2
      .Build()
  ```

  ```csharp
  connection = new HubConnectionBuilder()
      .WithUrl(...)
      .AddNewtonsoftJsonProtocol(...) // 3.0
      .Build()
  ```

## <a name="opt-in-to-runtime-compilation"></a>Fornire il consenso esplicito per la compilazione di runtime

In 3.0, la compilazione di runtime è uno scenario di consenso esplicito. Per abilitare la compilazione di runtime, vedere <xref:mvc/views/view-compilation#runtime-compilation>.
