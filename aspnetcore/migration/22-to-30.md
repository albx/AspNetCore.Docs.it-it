---
title: Eseguire la migrazione da ASP.NET Core 2,2 a 3,0 Preview
author: rick-anderson
description: Informazioni su come eseguire la migrazione di un progetto ASP.NET Core 2,2 ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/16/2019
uid: migration/22-to-30
ms.openlocfilehash: ce16961c8a30ed4b905d5a20b2230fbde269a3ed
ms.sourcegitcommit: b1e480e1736b0fe0e4d8dce4a4cf5c8e47fc2101
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/19/2019
ms.locfileid: "71108041"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Eseguire la migrazione da ASP.NET Core 2,2 a 3,0

Di [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Questo articolo illustra come aggiornare un progetto di ASP.NET Core 2,2 esistente a ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prerequisiti

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio per Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Aggiornare il file di progetto

* Impostare il [moniker del Framework di destinazione (TFM)](/dotnet/standard/frameworks) su `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Rimuovere Any `<PackageReference>` nel metapacchetto [Microsoft. AspNetCore. All](xref:fundamentals/metapackage) o [Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app) .

* Rimuovere Any `<PackageReference>` nel pacchetto [Microsoft. AspNetCore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Se l'applicazione usa gli [analizzatori di API](xref:web-api/advanced/analyzers), `<PackageReference>` rimuovere qualsiasi elemento per il pacchetto [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) . Modificare il file di progetto per usare l'analizzatore fornito come parte del .NET Core SDK:

```xml
<PropertyGroup>
 <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
</PropertyGroup>
```

* Aggiornare l' `Version` attributo sugli elementi `<PackageReference>` rimanenti `Microsoft.AspNetCore.*` per i pacchetti nell'anteprima corrente (ad esempio `3.0.0-preview5-19227-01`,).

  Se non è disponibile una versione 3,0 di un pacchetto, il pacchetto potrebbe essere stato deprecato in 3,0. Molti di questi pacchetti fanno parte di `Microsoft.AspNetCore.App` e non è necessario farvi riferimento singolarmente. Per un elenco preliminare dei pacchetti non più prodotti in 3,0, vedere [interrompere la produzione di pacchetti per assembly di Framework condivisi in 3,0 (ASPNET/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). Il *Framework condiviso* è il set di assembly (file con*estensione dll* ) installati nel computer e a `Microsoft.AspNetCore.App`cui fa riferimento. Per altre informazioni, vedere [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Il framework condiviso).

* Gli assembly per diversi componenti rilevanti sono stati rimossi `Microsoft.AspNetCore.App` da in 3,0. Aggiungere `<PackageReference>` elementi se si usano API dei pacchetti elencati in [assembly rimossi da Microsoft. AspNetCore. app 3,0 (ASPNET/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Esempi di componenti rimossi includono:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  L'elenco di assembly di cui `Microsoft.AspNetCore.App` è in fase di spedizione non è stato finalizzato e cambierà prima della 3,0 RTM.

  Esaminare il codice seguente:

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  Il `ReadAsAsync` metodo chiamato nel codice precedente è incluso in `Microsoft.AspNet.WebApi.Client`. Installare il pacchetto NuGet [Microsoft. AspNet. WebAPI. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) per risolvere il problema di compilazione in 3,0.

* Aggiungere il [supporto per JSON.NET](#jsonnet-support).

* Per impostazione predefinita, i progetti sono [basati sul modello di hosting in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3,0 o versione successiva. Se il valore è `<AspNetCoreHostingModel>` `InProcess`, è possibile rimuovere facoltativamente la proprietà nel file di progetto.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configurazione

Eseguire la migrazione della configurazione di Gheppio al generatore host `ConfigureWebHostDefaults` Web fornito da (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se l'applicazione crea manualmente l'host con `HostBuilder`, chiamare `UseKestrel` sul generatore host Web in `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Il middleware della connessione sostituisce le schede di connessione

Gli adattatori<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>di connessione () sono stati rimossi da gheppio. Sostituire gli adapter di connessione con il middleware di connessione. Il middleware di connessione è simile al middleware HTTP nella pipeline ASP.NET Core ma per le connessioni di livello inferiore. HTTPS e registrazione connessione:

* Sono stati spostati dagli adattatori di connessione al middleware di connessione.
* Questi metodi di estensione funzionano come nelle versioni precedenti di ASP.NET Core. 

Per altre informazioni, vedere [l'esempio TlsFilterConnectionHandler nella sezione ListenOptions. Protocols dell'articolo di Gheppio](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Astrazioni del trasporto spostate e rese pubbliche

Il livello trasporto gheppio è stato esposto come interfaccia pubblica in `Connections.Abstractions`. Come parte di questi aggiornamenti:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`e i tipi associati sono stati rimossi.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>è stato spostato <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> da alle opzioni di trasporto.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>è stato rimosso <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>da.

Per altre informazioni, vedere le risorse di GitHub seguenti:

* [Astrazioni di rete client/server (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementare la nuova astrazione del listener del fondamento e riposizionare il gheppio in alto (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Intestazioni del trailer della richiesta gheppio

Per le app destinate a versioni precedenti di ASP.NET Core:

* Gheppio aggiunge intestazioni di trailer in blocchi HTTP/1.1 nella raccolta delle intestazioni della richiesta.
* I trailer sono disponibili dopo la lettura del corpo della richiesta fino alla fine.

Questo causa alcune problematiche relative all'ambiguità tra intestazioni e trailer, quindi i trailer sono stati spostati in una nuova raccolta (`RequestTrailerExtensions`) in 3,0.

I trailer della richiesta HTTP/2 sono:

* Non disponibile in ASP.NET Core 2,2.
* Disponibile in 3,0 come `RequestTrailerExtensions`.

Sono presenti nuovi metodi di estensione della richiesta per accedere a questi trailer. Come per HTTP/1.1, i trailer sono disponibili dopo la lettura del corpo della richiesta fino alla fine.

Per la versione 3,0 sono disponibili i `RequestTrailerExtensions` metodi seguenti:

* `GetDeclaredTrailers`Ottiene l'intestazione `Trailer` della richiesta che elenca i trailer da prevedere dopo il corpo. &ndash;
* `SupportsTrailers`&ndash; Indica se la richiesta supporta la ricezione di intestazioni trailer.
* `CheckTrailersAvailable`&ndash; Controlla se la richiesta supporta i trailer e se è disponibile per la lettura. Questo controllo non presuppone che siano presenti trailer da leggere. Non è possibile leggere i trailer anche se `true` viene restituito da questo metodo.
* `GetTrailer`&ndash; Ottiene l'intestazione finale richiesta dalla risposta. Verificare `SupportsTrailers` prima di `GetTrailer`chiamare oppure <xref:System.NotSupportedException> può verificarsi se la richiesta non supporta le intestazioni finali.

Per ulteriori informazioni, vedere [put trailer request in una raccolta separata (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO disabilitato

`AllowSynchronousIO`Abilita o Disabilita le API di i/o sincrono `HttpReqeuest.Body.Read`, `HttpResponse.Body.Write`ad esempio `Stream.Flush`, e. Queste API sono un'origine di inedia dei thread che causa arresti anomali dell'app. In 3,0 `AllowSynchronousIO` è disabilitato per impostazione predefinita. Per altre informazioni, vedere [la sezione i/o sincrona nell'articolo di Gheppio](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Oltre ad abilitare `AllowSynchronousIO` le opzioni `ConfigureKestrel`di con, l'i/o sincrono può essere sottoposto a override in base alle singole richieste come mitigazione temporanea:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se si riscontrano problemi <xref:System.IO.TextWriter> con le implementazioni o altri flussi che chiamano API sincrone in [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), chiamare invece la nuova <xref:System.IO.Stream.DisposeAsync*> API.

Per ulteriori informazioni, vedere [[annuncio] AllowSynchronousIO disabilitato in tutti i server (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. gheppio. https rimosso

In ASP.NET Core 2,1, il contenuto di *Microsoft. AspNetCore. Server. gheppio. HTTPS. dll* è stato spostato in *Microsoft. AspNetCore. Server. gheppio. Core. dll*. Si tratta di un aggiornamento senza interruzioni `TypeForwardedTo` che utilizza gli attributi. Per 3,0, l'assembly vuoto *Microsoft. AspNetCore. Server. gheppio. HTTPS. dll* (e il pacchetto NuGet) sono stati rimossi.

Le librerie che fanno riferimento a [Microsoft. AspNetCore. Server. gheppio. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devono aggiornare ASP.NET Core dipendenze a 2,1 o versione successiva.

Le app e le librerie destinate a ASP.NET Core 2,1 o versioni successive dovrebbero rimuovere tutti i riferimenti diretti al pacchetto [Microsoft. AspNetCore. Server. gheppio. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Supporto di Json.NET

Come parte del lavoro per [migliorare il Framework condiviso ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) è stato rimosso dal framework ASP.NET Core Shared. L'app può richiedere questo riferimento se usa `Newtonsoft.Json`funzionalità specifiche di, ad esempio JsonPatch o convertitori o se [Formatta](xref:web-api/advanced/formatting) `Newtonsoft.Json`tipi specifici.

Per usare Json.NET in un progetto ASP.NET Core 3,0:

* Aggiungere un riferimento al pacchetto a [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aggiornamento `Startup.ConfigureServices` da chiamare `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`è compatibile con i nuovi metodi di registrazione del servizio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Le impostazioni di Json.NET possono essere impostate nella chiamata `AddNewtonsoftJson`a:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registrazione del servizio MVC

ASP.NET Core 3,0 aggiunge nuove opzioni per la registrazione di scenari MVC `Startup.ConfigureServices`all'interno di.

Sono disponibili tre nuovi metodi di estensione di primo livello correlati a `IServiceCollection` scenari MVC in. I modelli utilizzano questi nuovi metodi anziché `UseMvc`. Tuttavia, `AddMvc` continua a comportarsi come nelle versioni precedenti.

Nell'esempio seguente viene aggiunto il supporto per i controller e le funzionalità relative alle API, ma non viste o pagine. Il modello API usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Nell'esempio seguente viene aggiunto il supporto per i controller, le funzionalità correlate all'API e le visualizzazioni, ma non le pagine. Il modello di applicazione Web (MVC) utilizza questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Nell'esempio seguente viene aggiunto il supporto per Razor Pages e il supporto minimo del controller. Il modello di applicazione Web usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

I nuovi metodi possono anche essere combinati. L'esempio seguente equivale a chiamare `AddMvc` in ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing del codice di avvio

Se un'app chiama `UseMvc` o `UseSignalR`, eseguire la migrazione dell'app al [routing dell'endpoint](xref:fundamentals/routing) , se possibile. Per migliorare la compatibilità del routing degli endpoint con le versioni precedenti di MVC, sono state ripristinate alcune delle modifiche apportate alla generazione di URL introdotte in ASP.NET Core 2,2. Se si sono verificati problemi durante l'uso del routing degli endpoint in 2,2, è previsto un miglioramento in ASP.NET Core 3,0 con le eccezioni seguenti:

* Se l'app implementa `IRouter` o eredita da `Route`, è possibile evitare di eseguire la migrazione in questo momento. Fornire commenti [e suggerimenti per pianificare la migrazione di implementazioni basate su IRouter nel routing degli endpoint](https://github.com/aspnet/AspNetCore/issues/4221).

* Se l'app accede `RouteData.Routers` direttamente all'interno di MVC, è consigliabile evitare di eseguire la migrazione in questo momento. Fornire commenti e suggerimenti sulle [indicazioni per la migrazione per l'uso di RouteData. router](https://github.com/aspnet/AspNetCore/issues/9148).

Il routing degli endpoint supporta la stessa sintassi del modello di route e le funzionalità `IRouter`di creazione di modelli di route di. Il routing degli `IRouteConstraint`endpoint supporta. Il routing degli `[Route]`endpoint `[HttpGet]`supporta, e gli altri attributi di routing MVC.

Per la maggior parte delle `Startup` applicazioni, è necessario apportare solo modifiche.

### <a name="migrate-startupconfigure"></a>Esegui la migrazione di startup. Configure

Consigli generali:

* Aggiungi `UseRouting`.
* Se l'app chiama `UseStaticFiles`, inserire `UseStaticFiles` **before** `UseRouting`.
* Se l'app usa funzionalità di autenticazione/autorizzazione come `AuthorizePage` o `[Authorize]`, inserire la chiamata a `UseAuthentication` e `UseAuthorization` **after** `UseRouting` (e **dopo** `UseCors` se viene usato il middleware CORS).
* Sostituire `UseMvc` o `UseSignalR` con .`UseEndpoints`
* Se l'app usa scenari [CORS](xref:security/cors) `[EnableCors]`, ad esempio, inserire la chiamata a prima di `UseCors` qualsiasi altro middleware che usa CORS (ad esempio, `UseCors` inserire `UseAuthentication`prima `UseAuthorization`di, `UseEndpoints`e).
* Sostituire `IHostingEnvironment` `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> con `IWebHostEnvironment` e aggiungere un'istruzione per lo spazio dei nomi.
* Sostituire `IApplicationLifetime` con <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> spazio dei nomi).
* Sostituire `EnvironmentName` con <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> spazio dei nomi).

Di seguito è riportato un esempio `Startup.Configure` di in una tipica app ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Dopo l'aggiornamento del `Startup.Configure` codice precedente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="health-checks"></a>Controlli di integrità

I controlli di integrità usano il routing degli endpoint con l'host generico. In `Startup.Configure`, chiamare `MapHealthChecks` sul generatore di endpoint con l'URL dell'endpoint o il percorso relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Gli endpoint di controllo integrità possono:

* Specificare uno o più host o porte consentiti.
* Richiedere l'autorizzazione.
* Richiede CORS.

Per altre informazioni, vedere <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Guida del middleware di sicurezza

Il supporto per l'autorizzazione e CORS è unificato intorno all'approccio [middleware](xref:fundamentals/middleware/index) . In questo modo è possibile usare lo stesso middleware e le stesse funzionalità in questi scenari. In questa versione è disponibile un middleware di autorizzazione aggiornato e il middleware CORS è stato migliorato in modo da poter comprendere gli attributi usati dai controller MVC.

#### <a name="cors"></a>CORS

In precedenza, CORS potrebbe essere difficile da configurare. Il middleware è stato fornito per alcuni casi d'uso, ma i filtri MVC erano destinati a essere usati **senza** il middleware in altri casi d'uso. Con ASP.NET Core 3,0, è consigliabile che tutte le app che richiedono CORS usino il middleware CORS in tandem con il routing degli endpoint. `UseCors`può essere fornito con un criterio predefinito, mentre `[EnableCors]` gli `[DisableCors]` attributi e possono essere utilizzati per eseguire l'override dei criteri predefiniti laddove necessario.

Nell'esempio seguente:

* CORS è abilitato per tutti gli endpoint con il `default` criterio denominato.
* La `MyController` classe Disabilita cors con l' `[DisableCors]` attributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

Nelle versioni precedenti di ASP.NET Core, il supporto dell'autorizzazione è stato `[Authorize]` fornito tramite l'attributo. Il middleware di autorizzazione non era disponibile. In ASP.NET Core 3,0 è necessario il middleware di autorizzazione. Si consiglia di inserire il middleware di autorizzazione`UseAuthorization`ASP.NET Core () `UseAuthentication`subito dopo. Il middleware di autorizzazione può essere configurato anche con criteri predefiniti, che possono essere sottoposti a override.

In ASP.NET Core 3,0 o versione successiva `UseAuthorization` , viene chiamato `Startup.Configure`in e per quanto `HomeController` segue è necessario un utente connesso:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Se l'app usa un `AuthorizeFilter` come filtro globale in MVC, è consigliabile effettuare il refactoring del codice per fornire un criterio nella chiamata a `AddAuthorization`.

Inizialmente `DefaultPolicy` è configurato per richiedere l'autenticazione, pertanto non è necessaria alcuna configurazione aggiuntiva. Nell'esempio seguente gli endpoint MVC sono contrassegnati come in `RequireAuthorization` modo che tutte le richieste devono essere autorizzate in base `DefaultPolicy`a. Tuttavia, `HomeController` consente l'accesso senza che l'utente acceda all'app a `[AllowAnonymous]`causa di:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

È anche possibile personalizzare i criteri. Basandosi sull'esempio precedente, `DefaultPolicy` è configurato per richiedere l'autenticazione e un ambito specifico:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

In alternativa, tutti gli endpoint possono essere configurati in modo `[Authorize]` da `RequireAuthorization` richiedere l'autorizzazione `FallbackPolicy`senza o configurando un. `FallbackPolicy` È diverso `DefaultPolicy`da. Il `DefaultPolicy` viene attivato da `[Authorize]` o `RequireAuthorization`, mentre l'oggetto `FallbackPolicy` viene attivato quando non è impostato alcun altro criterio. `FallbackPolicy`Inizialmente è configurato per consentire le richieste senza autorizzazione.

L'esempio seguente è identico a quello dell' `DefaultPolicy` esempio precedente, ma `FallbackPolicy` USA per richiedere sempre l'autenticazione su tutti gli endpoint `[AllowAnonymous]` tranne quando è specificato:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

L'autorizzazione da parte del middleware funziona senza il Framework con una conoscenza specifica dell'autorizzazione. Ad esempio, i [controlli di integrità](xref:host-and-deploy/health-checks) non hanno una conoscenza specifica dell'autorizzazione, ma i controlli di integrità possono avere un criterio di autorizzazione configurabile applicato dal middleware.

Ogni endpoint può inoltre personalizzare i requisiti di autorizzazione. `UseAuthorization` Nell'esempio seguente, elabora l'autorizzazione `DefaultPolicy`con, ma l' `/healthz` endpoint di controllo integrità richiede un `admin` utente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protezione viene implementata per alcuni scenari. `UseEndpoint`il middleware genera un'eccezione se un criterio di autorizzazione o di CORS viene ignorato a causa del middleware mancante. È in corso il supporto dell'analizzatore per fornire commenti e suggerimenti aggiuntivi sulla configurazione errata.

### <a name="signalr"></a>SignalR

Il mapping degli hub SignalR si verifica ora `UseEndpoints`all'interno di.

Eseguire il mapping di `MapHub`ogni hub con. Come nelle versioni precedenti, ogni hub è elencato in modo esplicito.

Nell'esempio seguente viene aggiunto il supporto per `ChatHub` l'hub SignalR:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

È disponibile una nuova opzione per controllare i limiti delle dimensioni dei messaggi dai client. Ad esempio, in `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.NET Core 2,2, è possibile impostare `TransportMaxBufferSize` e che consentono di controllare in modo efficace le dimensioni massime del messaggio. In ASP.NET Core 3,0 questa opzione consente ora di controllare solo le dimensioni massime prima che venga osservato il backpressure.

### <a name="mvc-controllers"></a>Controller MVC

Il mapping dei controller si verifica ora `UseEndpoints`all'interno di.

Aggiungere `MapControllers` se l'app usa il routing degli attributi. Poiché il routing include il supporto per molti Framework in ASP.NET Core 3,0 o versione successiva, l'aggiunta di controller indirizzati agli attributi è il consenso esplicito.

Sostituire quanto segue:

* `MapRoute`con`MapControllerRoute`
* `MapAreaRoute`con`MapAreaControllerRoute`

Poiché il routing include ora il supporto per più di MVC, la terminologia è stata modificata in modo da rendere questi metodi chiaramente quelli che eseguono. Le route convenzionali, `MapControllerRoute` ad esempio, / / `MapAreaControllerRoute` vengonoapplicatenell'ordineincuisonostateaggiunte.`MapDefaultControllerRoute` Posizionare prima le route più specifiche, ad esempio le route per un'area.

Nell'esempio seguente:

* `MapControllers`aggiunge il supporto per i controller indirizzati all'attributo.
* `MapAreaControllerRoute`aggiunge una route convenzionale per i controller in un'area.
* `MapControllerRoute`aggiunge una route convenzionale per i controller.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor Pages

Il mapping Razor Pages ora avviene all' `UseEndpoints`interno di.

Aggiungere `MapRazorPages` se l'app usa Razor Pages. Poiché il routing degli endpoint include il supporto per molti Framework, l'aggiunta di Razor Pages è ora il consenso esplicito.

Nell'esempio seguente, `MapRazorPages` aggiunge il supporto per Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usare MVC senza routing degli endpoint

Per usare MVC `UseMvc` tramite `UseMvcWithDefaultRoute` o in ASP.NET Core 3,0 è necessario un consenso esplicito `Startup.ConfigureServices`all'interno di. Questa operazione è necessaria perché MVC deve sapere se può basarsi sul middleware Authorization e CORS durante l'inizializzazione. Viene fornito un analizzatore che avvisa se l'app tenta di usare una configurazione non supportata.

Se l'app richiede il `IRouter` supporto legacy, `EnableEndpointRouting` disabilitare usando uno degli approcci seguenti in `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Controlli di integrità

I controlli di integrità possono essere usati come *router-Ware* con il routing degli endpoint.

Aggiungere `MapHealthChecks` per utilizzare i controlli di integrità con il routing degli endpoint. Il `MapHealthChecks` metodo accetta argomenti simili a `UseHealthChecks`. Il vantaggio di usare `MapHealthChecks` over `UseHealthChecks` è la possibilità di applicare l'autorizzazione e di avere un controllo più granulare sui criteri di corrispondenza.

Nell'esempio `MapHealthChecks` seguente viene chiamato per un endpoint di controllo integrità in `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder sostituisce WebHostBuilder

I modelli di ASP.NET Core 3,0 usano un [host generico](xref:fundamentals/host/generic-host). Le versioni precedenti usavano il [Web host](xref:fundamentals/host/web-host). Il codice seguente illustra la classe generata `Program` dal modello di ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Il codice seguente illustra la classe generata `Program` dal modello di ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>rimane in 3,0 e è il tipo di `webBuilder` visualizzato nell'esempio di codice precedente. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>verrà deprecato in una versione futura e sostituito da `HostBuilder`.

La modifica più significativa da `WebHostBuilder` a `HostBuilder` è nell' [inserimento delle dipendenze (di)](xref:fundamentals/dependency-injection). Quando si `HostBuilder`USA, è possibile inserire <xref:Microsoft.Extensions.Configuration.IConfiguration> solo <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> il `Startup`costruttore e in. Vincoli `HostBuilder` di di:

* Consente la compilazione del contenitore DI INSERIMENTO DI una sola volta.
* Evita i problemi di durata degli oggetti risultanti, ad esempio la risoluzione di più istanze di singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization spostato in un assembly diverso

Il ASP.NET Core 2,2 e i `AddAuthorization` metodi inferiori in *Microsoft. AspNetCore. Authorization. dll*:

* Sono stati rinominati `AddAuthorizationCore`.
* Sono state spostate in *Microsoft. AspNetCore. Authorization. Policy. dll*.

Le app che usano sia *Microsoft. AspNetCore. Authorization. dll* che *Microsoft. AspNetCore. Authorization. Policy. dll* non hanno alcun effetto.

Le app che non usano *Microsoft. AspNetCore. Authorization. Policy. dll* devono eseguire una delle operazioni seguenti:

* Passa a utilizzando`AddAuthorizationCore`
* Aggiungere un riferimento a *Microsoft. AspNetCore. Authorization. Policy. dll*.

Per ulteriori informazioni, vedere [Overload Change in `AddAuthorization(o =>`) si trova in un assembly diverso #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Codice SignalR

Il client JavaScript SignalR è stato modificato `@aspnet/signalr` da `@microsoft/signalr`a. Per rispondere a questa modifica, modificare i riferimenti in file *Package. JSON* , istruzioni require e istruzioni Import ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON è il protocollo predefinito

`System.Text.Json`è ora il protocollo dell'Hub predefinito usato dal client e dal server.

In `Startup.ConfigureServices`, chiamare `AddJsonProtocol` per impostare le opzioni del serializzatore.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Client:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Passa a Newtonsoft. JSON

Se si usano funzionalità di `Newtonsoft.Json` che non sono supportate in `System.Text.Json`, è possibile tornare a: `Newtonsoft.Json`

1. Installare il pacchetto NuGet [Microsoft. AspNetCore. SignalR. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Nel client, concatenare `AddNewtonsoftJsonProtocol` una chiamata `HubConnectionBuilder` al metodo all'istanza:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Nel server, concatenare `AddNewtonsoftJsonProtocol` una chiamata `AddSignalR` al metodo alla chiamata al `Startup.ConfigureServices`metodo in:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Acconsenti esplicitamente alla compilazione del runtime

In 3,0, la compilazione in fase di esecuzione è uno scenario di consenso esplicito. Per abilitare la compilazione in fase <xref:mvc/views/view-compilation#runtime-compilation>di esecuzione, vedere.
