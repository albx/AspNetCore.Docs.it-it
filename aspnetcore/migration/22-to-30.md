---
title: Eseguire la migrazione da ASP.NET Core 2,2 a 3,0
author: rick-anderson
description: Informazioni su come eseguire la migrazione di un progetto ASP.NET Core 2,2 ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 142ef4ed7776a213fec6528839555001436ebda3
ms.sourcegitcommit: eca76bd065eb94386165a0269f1e95092f23fa58
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/24/2020
ms.locfileid: "76727190"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Eseguire la migrazione da ASP.NET Core 2,2 a 3,0

Di [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Questo articolo illustra come aggiornare un progetto di ASP.NET Core 2,2 esistente a ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prerequisiti

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio per Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aggiornare la versione di .NET Core SDK in global.json

Se la soluzione si basa su un file [Global. JSON](/dotnet/core/tools/global-json) per fare riferimento a una versione specifica di .NET Core SDK, aggiornare la relativa proprietà `version` alla versione 3,0 installata nel computer:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aggiornare il file di progetto

### <a name="update-the-target-framework"></a>Aggiornare il Framework di destinazione

ASP.NET Core 3,0 e versioni successive vengono eseguiti solo in .NET Core. Impostare il [moniker del Framework di destinazione (TFM)](/dotnet/standard/frameworks) su `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Rimuovi riferimenti ai pacchetti obsoleti

Un numero elevato di pacchetti NuGet non viene prodotto per ASP.NET Core 3,0. Tali riferimenti ai pacchetti devono essere rimossi dal file di progetto. Si consideri il seguente file di progetto per un'app Web ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Il file di progetto aggiornato per ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Il file di progetto ASP.NET Core 3,0 aggiornato:

* Nel `<PropertyGroup>` eseguire le operazioni seguenti:
  * Aggiorna TFM per `netcoreapp3.0`
  * Rimuove l'elemento `<AspNetCoreHostingModel>`. Per ulteriori informazioni, vedere [modello di hosting in-process](#in-process-hosting-model) in questo documento.

* Nel `<ItemGroup>` eseguire le operazioni seguenti:
  * `Microsoft.AspNetCore.App` è stato rimosso. Per ulteriori informazioni, vedere [riferimento a Framework](#framework-reference) in questo documento.
  * `Microsoft.AspNetCore.Razor.Design` viene rimosso e nell'elenco seguente di pacchetti non viene più generato.

Per visualizzare l'elenco completo dei pacchetti non più prodotti, selezionare il seguente elenco di espansione:

<details>
    <summary>Fare clic per espandere l'elenco dei pacchetti che non vengono più prodotti</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore.SignalR. Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Esaminare le modifiche di rilievo

[Esaminare le modifiche di rilievo](#break)

### <a name="framework-reference"></a>Riferimento a Framework

Le funzionalità di ASP.NET Core disponibili tramite uno dei pacchetti elencati in precedenza sono disponibili come parte del Framework condiviso `Microsoft.AspNetCore.App`. Il *Framework condiviso* è il set di assembly (file con*estensione dll* ) installato nel computer e include un componente di runtime e un Targeting Pack. Per altre informazioni, vedere [The shared framework](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) (Il framework condiviso).

* I progetti destinati a `Microsoft.NET.Sdk.Web` SDK fanno riferimento in modo implicito a `Microsoft.AspNetCore.App` Framework.

  Per questi progetti non sono necessari riferimenti aggiuntivi:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* I progetti destinati a `Microsoft.NET.Sdk` o `Microsoft.NET.Sdk.Razor` SDK devono aggiungere un `FrameworkReference` esplicito a `Microsoft.AspNetCore.App`:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Compilazioni dipendenti dal Framework con Docker

Le compilazioni dipendenti dal framework delle app console che usano un pacchetto che dipende dal [Framework condiviso](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.NET Core possono restituire l'errore di runtime seguente:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` è il Framework condiviso che contiene il runtime di ASP.NET Core ed è presente solo nell'immagine di Docker [DotNet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) . 3,0 SDK riduce le dimensioni delle compilazioni dipendenti dal Framework utilizzando ASP.NET Core senza includere copie duplicate delle librerie disponibili nel Framework condiviso. Si tratta di un risparmio potenziale di un massimo di 18 MB, ma richiede che il runtime di ASP.NET Core sia presente/installato per l'esecuzione dell'app.

Per determinare se l'app ha una dipendenza (diretta o indiretta) nel Framework condiviso ASP.NET Core, esaminare il file *runtimeconfig. JSON* generato durante una compilazione/pubblicazione dell'app. Il file JSON seguente mostra una dipendenza dal Framework condiviso ASP.NET Core:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Se l'app usa Docker, usare un'immagine di base che includa ASP.NET Core 3,0. Ad esempio `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Aggiungere i riferimenti al pacchetto per gli assembly rimossi

ASP.NET Core 3,0 rimuove alcuni assembly che in precedenza facevano parte del riferimento al pacchetto `Microsoft.AspNetCore.App`. Per visualizzare gli assembly rimossi, confrontare le due cartelle del Framework condivise. Ad esempio, un confronto tra le versioni 2.2.7 e 3.0.0:

![confronto degli assembly del Framework condiviso](22-to-30/_static/assembly-diff.png)

Per continuare a utilizzare le funzionalità fornite dagli assembly rimossi, fare riferimento alle versioni 3,0 dei pacchetti corrispondenti:

* Per un'app Web generata da un modello con **account utente singoli** è necessario aggiungere i pacchetti seguenti:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Per ulteriori informazioni sul riferimento al pacchetto specifico del provider di database, vedere [provider di database](/ef/core/providers/index).

* Interfaccia utente identità

  È possibile aggiungere il supporto per l' [interfaccia utente di identità](xref:security/authentication/identity) facendo riferimento al pacchetto [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Servizi SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Il supporto per l'autenticazione &ndash; per i flussi di autenticazione di terze parti è disponibile come pacchetto NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Autenticazione dell'account Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticazione OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Bearer token OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticazione di WsFederation ([Microsoft. AspNetCore. Authentication. WSFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Formattazione e supporto per la negoziazione del contenuto per `System.Net.HttpClient` &ndash; il pacchetto NuGet [Microsoft. AspNet. WebAPI. client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) fornisce un'estendibilità utile per `System.Net.HttpClient` con le API, ad esempio `ReadAsAsync` e `PostJsonAsync`.

* La compilazione del runtime Razor &ndash; il supporto per la compilazione in fase di esecuzione delle visualizzazioni Razor e delle pagine fa ora parte di [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Il supporto di MVC `Newtonsoft.Json` (Json.NET) &ndash; supporto per l'uso di MVC con `Newtonsoft.Json` fa ora parte di [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Modifiche all'avvio

La figura seguente mostra le righe eliminate e modificate in un'app Web ASP.NET Core 2,2 Razor Pages:

![righe eliminate e modificate in un'app Web Razor ASP.NET Core 2,2](22-to-30/_static/startup2.2.png)

Nell'immagine precedente, il codice eliminato viene visualizzato in rosso. Il codice eliminato non Mostra il codice delle opzioni dei cookie, che è stato eliminato prima di confrontare i file.

La figura seguente mostra le righe aggiunte e modificate in un'app Web ASP.NET Core 3,0 Razor Pages:

![righe aggiunte e modificate in un'app Web Razor ASP.NET Core 3,0](22-to-30/_static/startup3.0.png)

Nell'immagine precedente, il codice aggiunto viene visualizzato in verde. Per informazioni sulle modifiche seguenti:

* `services.AddMvc` `services.AddRazorPages`, vedere la pagina relativa alla [registrazione del servizio MVC](#mvc-service-registration) in questo documento.
* `CompatibilityVersion`, vedere <xref:mvc/compatibility-version>.
* `IHostingEnvironment` `IWebHostEnvironment`, vedere [questo annuncio su GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` è stato aggiunto ai modelli per mostrare che è necessario aggiungere il middleware di autorizzazione degli ordini. Se l'app non usa l'autorizzazione, è possibile rimuovere in modo sicuro la chiamata a `app.UseAuthorization`.
* `app.UseEndpoints`, vedere [Razor Pages](#razor-pages) o [migrare Startup. Configure](#migrate-startupconfigure) in questo documento.

### <a name="analyzer-support"></a>Supporto analizzatore

I progetti destinati `Microsoft.NET.Sdk.Web` fanno riferimento in modo implicito agli analizzatori forniti in precedenza come parte del pacchetto [Microsoft. AspNetCore. Mvc. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Per abilitare queste informazioni non sono necessari altri riferimenti.

Se l'app usa gli [analizzatori di API](xref:web-api/advanced/analyzers) forniti in precedenza usando il pacchetto [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , modificare il file di progetto in modo che faccia riferimento agli analizzatori forniti come parte di .NET Core Web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Libreria di classi Razor

I progetti della libreria di classi Razor che forniscono componenti dell'interfaccia utente per MVC devono impostare la proprietà `AddRazorSupportForMvc` nel file di progetto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modello di hosting in-process

Per impostazione predefinita, i progetti sono [basati sul modello di hosting in-process](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3,0 o versione successiva. Se il relativo valore è `InProcess`, è possibile rimuovere facoltativamente la proprietà `<AspNetCoreHostingModel>` nel file di progetto.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configurazione di

Eseguire la migrazione della configurazione di Gheppio al generatore host Web fornito da `ConfigureWebHostDefaults` (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se l'applicazione crea manualmente l'host con `HostBuilder`, chiamare `UseKestrel` sul generatore host Web in `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Il middleware della connessione sostituisce le schede di connessione

Le schede di connessione (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) sono state rimosse da gheppio. Sostituire gli adapter di connessione con il middleware di connessione. Il middleware di connessione è simile al middleware HTTP nella pipeline ASP.NET Core ma per le connessioni di livello inferiore. HTTPS e registrazione connessione:

* Sono stati spostati dagli adattatori di connessione al middleware di connessione.
* Questi metodi di estensione funzionano come nelle versioni precedenti di ASP.NET Core. 

Per altre informazioni, vedere [l'esempio TlsFilterConnectionHandler nella sezione ListenOptions. Protocols dell'articolo di Gheppio](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Astrazioni del trasporto spostate e rese pubbliche

Il livello trasporto Kestrel è stato esposto come interfaccia pubblica in `Connections.Abstractions`. Come parte di questi aggiornamenti:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` e i tipi associati sono stati rimossi.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> stato spostato da <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> alle opzioni di trasporto.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` è stato rimosso da <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Per altre informazioni, vedere le risorse di GitHub seguenti:

* [Astrazioni di rete client/server (#10308 DotNet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementare la nuova astrazione del listener del fondamento e ricostruire il gheppio in alto (DotNet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Intestazioni del trailer della richiesta gheppio

Per le app destinate a versioni precedenti di ASP.NET Core:

* Gheppio aggiunge intestazioni di trailer in blocchi HTTP/1.1 nella raccolta delle intestazioni della richiesta.
* I trailer sono disponibili dopo la lettura del corpo della richiesta fino alla fine.

Questo causa alcune problematiche relative all'ambiguità tra le intestazioni e i trailer, quindi i trailer sono stati spostati in una nuova raccolta (`RequestTrailerExtensions`) in 3,0.

I trailer della richiesta HTTP/2 sono:

* Non disponibile in ASP.NET Core 2,2.
* Disponibile in 3,0 come `RequestTrailerExtensions`.

Sono presenti nuovi metodi di estensione della richiesta per accedere a questi trailer. Come per HTTP/1.1, i trailer sono disponibili dopo la lettura del corpo della richiesta fino alla fine.

Per la versione 3,0 sono disponibili i seguenti metodi di `RequestTrailerExtensions`:

* `GetDeclaredTrailers` &ndash; Ottiene l'intestazione `Trailer` della richiesta che elenca i trailer da prevedere dopo il corpo.
* `SupportsTrailers` &ndash; indica se la richiesta supporta la ricezione di intestazioni trailer.
* `CheckTrailersAvailable` &ndash; controlla se la richiesta supporta i trailer e se è disponibile per la lettura. Questo controllo non presuppone che siano presenti trailer da leggere. Non è possibile leggere i trailer anche se `true` viene restituito da questo metodo.
* `GetTrailer` &ndash; Ottiene l'intestazione finale richiesta dalla risposta. Controllare `SupportsTrailers` prima di chiamare `GetTrailer`oppure è possibile che si verifichi un <xref:System.NotSupportedException> se la richiesta non supporta le intestazioni finali.

Per altre informazioni, vedere [inserire i trailer delle richieste in una raccolta separata (DotNet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO disabilitato

`AllowSynchronousIO` Abilita o Disabilita le API i/o sincrone, ad esempio `HttpRequest.Body.Read`, `HttpResponse.Body.Write`e `Stream.Flush`. Queste API sono un'origine di inedia dei thread che causa arresti anomali dell'app. In 3.0, `AllowSynchronousIO` è disabilitato per impostazione predefinita. Per altre informazioni, vedere [la sezione i/o sincrona nell'articolo di Gheppio](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Se è necessario l'i/o sincrono, è possibile abilitarlo configurando l'opzione `AllowSynchronousIO` sul server usato (quando si chiama `ConfigureKestrel`, ad esempio, se si usa gheppio). Si noti che i server (gheppio, HttpSys, TestServer e così via) hanno tutti una propria `AllowSynchronousIO` opzione che non influirà sugli altri server. L'i/o sincrono può essere abilitato per tutti i server in base alle singole richieste usando l'opzione `IHttpBodyControlFeature.AllowSynchronousIO`:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se si riscontrano problemi con le implementazioni di <xref:System.IO.TextWriter> o altri flussi che chiamano API sincrone in [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), chiamare invece la nuova API <xref:System.IO.Stream.DisposeAsync*>.

Per ulteriori informazioni, vedere [[annuncio] AllowSynchronousIO disabilitato in tutti i server (#7644 DotNet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. gheppio. https rimosso

In ASP.NET Core 2,1, il contenuto di *Microsoft. AspNetCore. Server. gheppio. HTTPS. dll* è stato spostato in *Microsoft. AspNetCore. Server. gheppio. Core. dll*. Si tratta di un aggiornamento senza interruzioni che utilizza gli attributi `TypeForwardedTo`. Per 3,0, l'assembly *Microsoft. AspNetCore. Server. gheppio. HTTPS. dll* vuoto e il pacchetto NuGet sono stati rimossi.

Le librerie che fanno riferimento a [Microsoft. AspNetCore. Server. gheppio. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devono aggiornare ASP.NET Core dipendenze a 2,1 o versione successiva.

Le app e le librerie destinate a ASP.NET Core 2,1 o versioni successive dovrebbero rimuovere tutti i riferimenti diretti al pacchetto [Microsoft. AspNetCore. Server. gheppio. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Supporto di Newtonsoft. JSON (Json.NET)

Come parte del lavoro per [migliorare il Framework condiviso ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Newtonsoft. JSON (JSON.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) è stato rimosso dal Framework condiviso ASP.NET Core.

Il serializzatore JSON predefinito per ASP.NET Core è ora <xref:System.Text.Json>, che è una novità di .NET Core 3,0. Quando possibile, provare a usare `System.Text.Json`. Si tratta di prestazioni elevate e non richiede una dipendenza della libreria aggiuntiva. Tuttavia, poiché `System.Text.Json` è nuovo, è possibile che al momento non siano presenti funzionalità necessarie per l'app. Per altre informazioni, vedere [How to migrate from Newtonsoft. JSON to System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Usare Newtonsoft. JSON in un progetto SignalR di ASP.NET Core 3,0

* Installare [Microsoft. AspNetCore.SignalR. Pacchetto NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .

* Nel client, concatenare una chiamata al metodo `AddNewtonsoftJsonProtocol` all'istanza di `HubConnectionBuilder`:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Nel server, concatenare una chiamata al metodo `AddNewtonsoftJsonProtocol` alla chiamata al metodo `AddSignalR` in `Startup.ConfigureServices`:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Usare Newtonsoft. JSON in un progetto MVC ASP.NET Core 3,0

* Installare il pacchetto [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

* Aggiornare `Startup.ConfigureServices` per chiamare `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` è compatibile con i nuovi metodi di registrazione del servizio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  è possibile impostare le impostazioni di `Newtonsoft.Json` nella chiamata a `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Nota:** Se il metodo `AddNewtonsoftJson` non è disponibile, assicurarsi di aver installato il pacchetto [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) . Un errore comune consiste nell'installare il pacchetto [Newtonsoft. JSON](https://www.nuget.org/packages/Newtonsoft.Json/) anziché il pacchetto [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="mvc-service-registration"></a>Registrazione del servizio MVC

ASP.NET Core 3,0 aggiunge nuove opzioni per la registrazione di scenari MVC all'interno `Startup.ConfigureServices`.

Sono disponibili tre nuovi metodi di estensione di primo livello correlati a scenari MVC in `IServiceCollection`. I modelli utilizzano questi nuovi metodi anziché `AddMvc`. Tuttavia, `AddMvc` continua a comportarsi come nelle versioni precedenti.

Nell'esempio seguente viene aggiunto il supporto per i controller e le funzionalità relative alle API, ma non viste o pagine. Il modello API usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Nell'esempio seguente viene aggiunto il supporto per i controller, le funzionalità correlate all'API e le visualizzazioni, ma non le pagine. Il modello di applicazione Web (MVC) utilizza questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Nell'esempio seguente viene aggiunto il supporto per Razor Pages e il supporto minimo del controller. Il modello di applicazione Web usa questo codice:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

I nuovi metodi possono anche essere combinati. L'esempio seguente equivale a chiamare `AddMvc` in ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Routing del codice di avvio

Se un'app chiama `UseMvc` o `UseSignalR`, eseguire la migrazione dell'app al [routing dell'endpoint](xref:fundamentals/routing) , se possibile. Per migliorare la compatibilità del routing degli endpoint con le versioni precedenti di MVC, sono state ripristinate alcune delle modifiche apportate alla generazione di URL introdotte in ASP.NET Core 2,2. Se si sono verificati problemi durante l'uso del routing degli endpoint in 2,2, è previsto un miglioramento in ASP.NET Core 3,0 con le eccezioni seguenti:

* Se l'app implementa `IRouter` o eredita da `Route`, usare [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) come sostituzione.

* Se l'app accede direttamente `RouteData.Routers` all'interno di MVC per analizzare gli URL, è possibile sostituirla con l'uso di `LinkParser.ParsePathByEndpointName`. 
 * Definire la route con un nome di route.
 * Usare `LinkParser.ParsePathByEndpointName` e passare il nome della route desiderata.

Il routing degli endpoint supporta la stessa sintassi del modello di route e le funzionalità di creazione di modelli di route come `IRouter`. Il routing degli endpoint supporta `IRouteConstraint`. Il routing degli endpoint supporta `[Route]`, `[HttpGet]`e gli altri attributi di routing MVC.

Per la maggior parte delle applicazioni, è necessario modificare solo `Startup`.

### <a name="migrate-startupconfigure"></a>Esegui la migrazione di startup. Configure

Consigli generali:

* Aggiungere `UseRouting`.
* Se l'app chiama `UseStaticFiles`, inserire `UseStaticFiles` **prima** di `UseRouting`.
* Se l'app usa funzionalità di autenticazione/autorizzazione come `AuthorizePage` o `[Authorize]`, inserire la chiamata `UseAuthentication` e `UseAuthorization`: **after**, `UseRouting` e `UseCors`, ma prima di `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Sostituire `UseMvc` o `UseSignalR` con `UseEndpoints`.
* Se l'app usa scenari [CORS](xref:security/cors) , ad esempio `[EnableCors]`, inserire la chiamata a `UseCors` prima di qualsiasi altro middleware che usa CORS (ad esempio, inserire `UseCors` prima di `UseAuthentication`, `UseAuthorization`e `UseEndpoints`).
* Sostituire `IHostingEnvironment` con `IWebHostEnvironment` e aggiungere un'istruzione `using` per lo spazio dei nomi <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Sostituire `IApplicationLifetime` con <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (spazio dei nomi<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).
* Sostituire `EnvironmentName` con <xref:Microsoft.Extensions.Hosting.Environments> (spazio dei nomi<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).

Il codice seguente è un esempio di `Startup.Configure` in una tipica app ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Dopo l'aggiornamento del codice di `Startup.Configure` precedente:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Per la maggior parte delle app, le chiamate a `UseAuthentication`, `UseAuthorization`e `UseCors` devono essere visualizzate tra le chiamate a `UseRouting` e `UseEndpoints` per essere effettive.

### <a name="health-checks"></a>Controlli di integrità

I controlli di integrità usano il routing degli endpoint con l'host generico. In `Startup.Configure`chiamare `MapHealthChecks` sul generatore di endpoint con l'URL dell'endpoint o il percorso relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Gli endpoint di controllo integrità possono:

* Specificare uno o più host o porte consentiti.
* Richiedere l'autorizzazione.
* Richiede CORS.

Per ulteriori informazioni, vedere <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Guida del middleware di sicurezza

Il supporto per l'autorizzazione e CORS è unificato intorno all'approccio [middleware](xref:fundamentals/middleware/index) . In questo modo è possibile usare lo stesso middleware e le stesse funzionalità in questi scenari. In questa versione è disponibile un middleware di autorizzazione aggiornato e il middleware CORS è stato migliorato in modo da poter comprendere gli attributi usati dai controller MVC.

#### <a name="cors"></a>CORS

In precedenza, CORS potrebbe essere difficile da configurare. Il middleware è stato fornito per alcuni casi d'uso, ma i filtri MVC erano destinati a essere usati **senza** il middleware in altri casi d'uso. Con ASP.NET Core 3,0, è consigliabile che tutte le app che richiedono CORS usino il middleware CORS in tandem con il routing degli endpoint. `UseCors` possono essere forniti con un criterio predefinito ed è possibile usare gli attributi `[EnableCors]` e `[DisableCors]` per eseguire l'override dei criteri predefiniti, se necessario.

Nell'esempio seguente:

* CORS è abilitato per tutti gli endpoint con il criterio denominato `default`.
* La classe `MyController` Disabilita CORS con l'attributo `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizzazione

Nelle versioni precedenti di ASP.NET Core, il supporto dell'autorizzazione è stato fornito tramite l'attributo `[Authorize]`. Il middleware di autorizzazione non era disponibile. In ASP.NET Core 3,0 è necessario il middleware di autorizzazione. Si consiglia di inserire il middleware di autorizzazione ASP.NET Core (`UseAuthorization`) subito dopo `UseAuthentication`. Il middleware di autorizzazione può essere configurato anche con criteri predefiniti, che possono essere sottoposti a override.

In ASP.NET Core 3,0 o versioni successive `UseAuthorization` viene chiamato in `Startup.Configure`e il `HomeController` seguente richiede un utente connesso:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Quando si usa il routing degli endpoint, è consigliabile evitare di configurare `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` e di basarsi invece sul middleware di autorizzazione.  Se l'app usa un `AuthorizeFilter` come filtro globale in MVC, è consigliabile effettuare il refactoring del codice per fornire un criterio nella chiamata a `AddAuthorization`.

Il `DefaultPolicy` è configurato inizialmente per richiedere l'autenticazione, pertanto non è necessaria alcuna configurazione aggiuntiva. Nell'esempio seguente gli endpoint MVC sono contrassegnati come `RequireAuthorization` in modo che tutte le richieste siano autorizzate in base al `DefaultPolicy`. Tuttavia, il `HomeController` consente l'accesso senza che l'utente acceda all'app a causa `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorizzazione per endpoint specifici

L'autorizzazione può essere configurata anche per classi specifiche di endpoint. Il codice seguente è un esempio di conversione di un'app MVC che ha configurato una `AuthorizeFilter` globale in un'app con criteri specifici che richiedono l'autorizzazione:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

È anche possibile personalizzare i criteri. Il `DefaultPolicy` è configurato per richiedere l'autenticazione:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

In alternativa, tutti gli endpoint possono essere configurati in modo da richiedere l'autorizzazione senza `[Authorize]` o `RequireAuthorization` configurando un `FallbackPolicy`. Il `FallbackPolicy` è diverso da quello `DefaultPolicy`. Il `DefaultPolicy` viene attivato da `[Authorize]` o `RequireAuthorization`, mentre il `FallbackPolicy` viene attivato quando non è impostato alcun altro criterio. `FallbackPolicy` viene inizialmente configurato per consentire le richieste senza autorizzazione.

L'esempio seguente è identico a quello dell'esempio precedente `DefaultPolicy` ma usa il `FallbackPolicy` per richiedere sempre l'autenticazione su tutti gli endpoint tranne quando viene specificato `[AllowAnonymous]`:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

L'autorizzazione da parte del middleware funziona senza il Framework con una conoscenza specifica dell'autorizzazione. Ad esempio, i [controlli di integrità](xref:host-and-deploy/health-checks) non hanno una conoscenza specifica dell'autorizzazione, ma i controlli di integrità possono avere un criterio di autorizzazione configurabile applicato dal middleware.

Ogni endpoint può inoltre personalizzare i requisiti di autorizzazione. Nell'esempio seguente `UseAuthorization` elabora l'autorizzazione con l'`DefaultPolicy`, ma l'endpoint di controllo integrità `/healthz` richiede un utente `admin`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protezione viene implementata per alcuni scenari. Il middleware degli endpoint genera un'eccezione se un criterio di autorizzazione o di CORS viene ignorato a causa del middleware mancante. È in corso il supporto dell'analizzatore per fornire commenti e suggerimenti aggiuntivi sulla configurazione errata.

#### <a name="custom-authorization-handlers"></a>Gestori di autorizzazione personalizzati

Se l'app usa [gestori di autorizzazione](xref:security/authorization/policies#authorization-handlers)personalizzati, il routing degli endpoint passa un tipo di risorsa diverso ai gestori rispetto a MVC. I gestori che prevedono che la risorsa del contesto del gestore di autorizzazione siano di tipo <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (il tipo di risorsa [fornito dai filtri MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)) dovranno essere aggiornati per gestire le risorse di tipo <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (il tipo di risorsa assegnato ai gestori di autorizzazione dal routing degli endpoint).

MVC usa ancora le risorse di `AuthorizationFilterContext`, quindi se l'app usa i filtri di autorizzazione MVC insieme all'autorizzazione per il routing degli endpoint, potrebbe essere necessario gestire entrambi i tipi di risorse.

### SignalR

Il mapping degli hub SignalR si verifica ora all'interno `UseEndpoints`.

Eseguire il mapping di ogni hub con `MapHub`. Come nelle versioni precedenti, ogni hub è elencato in modo esplicito.

Nell'esempio seguente viene aggiunto il supporto per l'hub SignalR `ChatHub`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

È disponibile una nuova opzione per controllare i limiti delle dimensioni dei messaggi dai client. Ad esempio, in `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

In ASP.NET Core 2,2, è possibile impostare il `TransportMaxBufferSize` e controllare in modo efficace le dimensioni massime del messaggio. In ASP.NET Core 3,0 questa opzione consente ora di controllare solo le dimensioni massime prima che venga osservato il backpressure.

### <a name="mvc-controllers"></a>Controller MVC

Il mapping dei controller si verifica ora all'interno `UseEndpoints`.

Aggiungere `MapControllers` se l'app usa il routing degli attributi. Poiché il routing include il supporto per molti Framework in ASP.NET Core 3,0 o versione successiva, l'aggiunta di controller indirizzati agli attributi è il consenso esplicito.

Sostituire gli elementi seguenti:

* `MapRoute` con `MapControllerRoute`
* `MapAreaRoute` con `MapAreaControllerRoute`

Poiché il routing include ora il supporto per più di MVC, la terminologia è stata modificata in modo da rendere questi metodi chiaramente quelli che eseguono. Le route convenzionali, ad esempio `MapControllerRoute`/`MapAreaControllerRoute`/`MapDefaultControllerRoute` vengono applicate nell'ordine in cui sono state aggiunte. Posizionare prima le route più specifiche, ad esempio le route per un'area.

Nell'esempio seguente:

* `MapControllers` aggiunge il supporto per i controller indirizzati all'attributo.
* `MapAreaControllerRoute` aggiunge una route convenzionale per i controller in un'area.
* `MapControllerRoute` aggiunge una route convenzionale per i controller.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Rimozione del suffisso asincrono dai nomi delle azioni del controller

In ASP.NET Core 3,0 ASP.NET Core MVC rimuove il suffisso `Async` dai nomi delle azioni del controller. Questo nuovo valore predefinito è influenzato dalla generazione del routing e del collegamento. Ad esempio:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Prima del ASP.NET Core 3,0:

* È possibile accedere all'azione precedente nella route *Products/ListAsync* .
* Per la generazione di collegamenti è necessario specificare il suffisso `Async`. Ad esempio:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

In ASP.NET Core 3,0:

* È possibile accedere all'azione precedente nella route *Products/List* .
* Per la generazione di collegamenti non è necessario specificare il suffisso `Async`. Ad esempio:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Questa modifica non influisce sui nomi specificati utilizzando l'attributo [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Il comportamento predefinito può essere disabilitato con il codice seguente `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Modifiche alla generazione del collegamento

Come illustrato nella documentazione relativa alle [differenze rispetto alle versioni precedenti del routing](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), esistono alcune differenze nella generazione dei collegamenti, ad esempio usando `Url.Link` e API simili. Sono inclusi:

* Per impostazione predefinita, quando si usa il routing degli endpoint, la combinazione dei parametri di route negli URI generati non viene necessariamente mantenuta. Questo comportamento può essere controllato con l'interfaccia `IOutboundParameterTransformer`.
* La generazione di un URI per una route non valida (un controller/azione o una pagina inesistente) produrrà una stringa vuota sotto il routing dell'endpoint anziché produrre un URI non valido.
* I valori di ambiente (parametri di route dal contesto corrente) non vengono usati automaticamente nella generazione del collegamento con il routing degli endpoint. In precedenza, durante la generazione di un collegamento a un'altra azione (o pagina), i valori di route non specificati verrebbero dedotti dai valori di ambiente delle route *correnti* . Quando si usa il routing degli endpoint, tutti i parametri di route devono essere specificati in modo esplicito durante la generazione del collegamento.

### <a name="razor-pages"></a>Razor Pages

Il mapping Razor Pages ora avviene all'interno `UseEndpoints`.

Aggiungere `MapRazorPages` se l'app usa Razor Pages. Poiché il routing degli endpoint include il supporto per molti Framework, l'aggiunta di Razor Pages è ora il consenso esplicito.

Nel metodo di `Startup.Configure` seguente `MapRazorPages` aggiunge il supporto per Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usare MVC senza routing degli endpoint

L'uso di MVC tramite `UseMvc` o `UseMvcWithDefaultRoute` in ASP.NET Core 3,0 richiede un consenso esplicito all'interno `Startup.ConfigureServices`. Questa operazione è necessaria perché MVC deve sapere se può basarsi sul middleware Authorization e CORS durante l'inizializzazione. Viene fornito un analizzatore che avvisa se l'app tenta di usare una configurazione non supportata.

Se l'app richiede il supporto `IRouter` legacy, disabilitare `EnableEndpointRouting` usando uno degli approcci seguenti in `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Controlli di integrità

I controlli di integrità possono essere usati come *router-Ware* con il routing degli endpoint.

Aggiungere `MapHealthChecks` per utilizzare i controlli di integrità con il routing degli endpoint. Il metodo `MapHealthChecks` accetta argomenti simili a `UseHealthChecks`. Il vantaggio di usare `MapHealthChecks` rispetto `UseHealthChecks` è la possibilità di applicare l'autorizzazione e di avere un controllo più granulare sui criteri di corrispondenza.

Nell'esempio seguente viene chiamato `MapHealthChecks` per un endpoint di controllo integrità in `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder sostituisce WebHostBuilder

I modelli di ASP.NET Core 3,0 usano un [host generico](xref:fundamentals/host/generic-host). Le versioni precedenti usavano il [Web host](xref:fundamentals/host/web-host). Il codice seguente illustra il modello di ASP.NET Core 3,0 generato `Program` classe:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Il codice seguente illustra la classe `Program` generata dal modello ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> rimane in 3,0 e è il tipo di `webBuilder` visualizzato nell'esempio di codice precedente. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> sarà deprecata in una versione futura e sostituita da `HostBuilder`.

La modifica più significativa da `WebHostBuilder` a `HostBuilder` è nell' [inserimento delle dipendenze (di)](xref:fundamentals/dependency-injection). Quando si usa `HostBuilder`, è possibile inserire quanto segue solo nel costruttore di `Startup`:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

I vincoli DI `HostBuilder` DI:

* Consente la compilazione del contenitore DI INSERIMENTO DI una sola volta.
* Evita i problemi di durata degli oggetti risultanti, ad esempio la risoluzione di più istanze di singleton.

Per altre informazioni, vedere [evitare l'inserimento del servizio di avvio in ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization spostato in un assembly diverso

Il ASP.NET Core 2,2 e i metodi di `AddAuthorization` inferiori in *Microsoft. AspNetCore. Authorization. dll*:

* Sono stati rinominati `AddAuthorizationCore`.
* Sono state spostate in *Microsoft. AspNetCore. Authorization. Policy. dll*.

Le app che usano sia *Microsoft. AspNetCore. Authorization. dll* che *Microsoft. AspNetCore. Authorization. Policy. dll* non hanno alcun effetto.

Le app che non usano *Microsoft. AspNetCore. Authorization. Policy. dll* devono eseguire una delle operazioni seguenti:

* Aggiungere un riferimento a *Microsoft. AspNetCore. Authorization. Policy. dll*. Questo approccio funziona per la maggior parte delle app ed è tutto ciò che è necessario.
* Passa a utilizzando `AddAuthorizationCore`

Per ulteriori informazioni, vedere [Overload Change in `AddAuthorization(o =>`) si trova in un assembly diverso #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Interfaccia utente identità

Aggiornamenti dell'interfaccia utente di Identity per ASP.NET Core 3,0:

* Aggiungere un riferimento al pacchetto a [Microsoft. AspNetCore. Identity. UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Le app che non usano Razor Pages devono chiamare `MapRazorPages`. Vedere [Razor Pages](#razor-pages) in questo documento.
* Bootstrap 4 è il Framework dell'interfaccia utente predefinito. Impostare una proprietà del progetto `IdentityUIFrameworkVersion` per modificare il valore predefinito. Per altre informazioni, vedere [questo annuncio su GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Il client JavaScript SignalR è stato modificato da `@aspnet/signalr` a `@microsoft/signalr`. Per rispondere a questa modifica, modificare i riferimenti in file *Package. JSON* , istruzioni `require` e istruzioni `import` ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON è il protocollo predefinito

`System.Text.Json` è ora il protocollo dell'Hub predefinito usato dal client e dal server.

In `Startup.ConfigureServices`chiamare `AddJsonProtocol` per impostare le opzioni del serializzatore.

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Client:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Passa a Newtonsoft. JSON

Se si usano [le funzionalità di Newtonsoft. JSON che non sono supportate in System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), è possibile tornare a `Newtonsoft.Json`. Vedere [usare Newtonsoft. JSON in un progetto di SignalR ASP.NET Core 3,0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) più indietro in questo articolo.

## <a name="redis-distributed-caches"></a>Cache distribuite Redis

Il pacchetto [Microsoft. Extensions. Caching. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) non è disponibile per le app ASP.NET Core 3,0 o versioni successive. Sostituire il riferimento al pacchetto con [Microsoft. Extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Per ulteriori informazioni, vedere <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Acconsenti esplicitamente alla compilazione del runtime

Prima di ASP.NET Core 3,0, la compilazione in fase di esecuzione delle visualizzazioni era una funzionalità implicita del Framework. La compilazione del Runtime integra la compilazione delle visualizzazioni in fase di compilazione. Consente al Framework di compilare visualizzazioni e pagine Razor (file con*estensione cshtml* ) quando i file vengono modificati, senza dover ricompilare l'intera app. Questa funzionalità supporta lo scenario di apportare una modifica rapida nell'IDE e aggiornare il browser per visualizzare le modifiche.

In ASP.NET Core 3,0, la compilazione in fase di esecuzione è uno scenario di consenso esplicito. La compilazione in fase di compilazione è l'unico meccanismo per la compilazione della vista abilitata per impostazione predefinita. Il runtime si basa su Visual Studio o [DotNet-Watch](xref:tutorials/dotnet-watch) in Visual Studio Code per ricompilare il progetto quando rileva le modifiche apportate ai file con *estensione cshtml* . In Visual Studio le modifiche ai file con *estensione cs*, *cshtml*o *Razor* nel progetto da eseguire (<kbd>CTRL + F5</kbd>), ma non sottoposta a debug (<kbd>F5</kbd>), attivano la ricompilazione del progetto.

Per abilitare la compilazione di runtime nel progetto ASP.NET Core 3,0:

1. Installare il pacchetto NuGet [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).
1. Aggiornare `Startup.ConfigureServices` per chiamare `AddRazorRuntimeCompilation`:

    Per ASP.NET Core MVC, usare il codice seguente:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Per ASP.NET Core Razor Pages, usare il codice seguente:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Nell'esempio https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation viene illustrato un esempio di abilitazione condizionale della compilazione di runtime negli ambienti di sviluppo.

Per ulteriori informazioni sulla compilazione di file Razor, vedere <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Eseguire la migrazione delle librerie tramite il multitargeting

Le librerie spesso devono supportare più versioni di ASP.NET Core. La maggior parte delle librerie compilate con versioni precedenti di ASP.NET Core dovrebbe continuare a funzionare senza problemi. Le condizioni seguenti richiedono che l'app venga compilata in modo incrociato:

* La libreria si basa su una funzionalità con una modifica di [rilievo](#breaking-api-changes)binaria.
* La libreria desidera sfruttare le nuove funzionalità di ASP.NET Core 3,0. 

Ad esempio:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Usare `#ifdefs` per abilitare ASP.NET Core API specifiche di 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Per ulteriori informazioni sull'utilizzo delle API ASP.NET Core in una libreria di classi, vedere <xref:fundamentals/target-aspnetcore>.

## <a name="miscellaneous-changes"></a>Modifiche varie

Il sistema di convalida in .NET Core 3,0 e versioni successive considera i parametri non nullable o le proprietà associata come se disponesse di un attributo `[Required]`. Per ulteriori informazioni, vedere l' [attributo [Required]](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Pubblica

Eliminare le cartelle *bin* e *obj* nella directory del progetto.

## <a name="testserver"></a>TestServer

Per le app che usano <xref:Microsoft.AspNetCore.TestHost.TestServer> direttamente con l' [host generico](xref:fundamentals/host/web-host), creare il `TestServer` in un <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> in <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Modifiche delle API di rilievo

Esaminare le modifiche di rilievo:

* [Elenco completo delle modifiche di rilievo nella versione ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Modifiche all'API di rilievo in antifalsificazione, CORS, diagnostica, MVC e routing](https://github.com/aspnet/Announcements/issues/387). Questo elenco include modifiche di rilievo per le opzioni di compatibilità.
* Per un riepilogo delle modifiche di rilievo da 2,2 a 3,0 in .NET Core, ASP.NET Core e Entity Framework Core, vedere [modifiche di rilievo per la migrazione dalla versione 2,2 alla versione 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 nel servizio app Azure

Per lo stato dell'implementazione di .NET Core al servizio app Azure, vedere il sito web ufficiale di [.NET Core nel servizio app](https://aspnetcoreon.azurewebsites.net/) . Fino a quando .NET Core 3,0 non è disponibile nel servizio app Azure, seguire le istruzioni in [distribuire ASP.NET Core versione di anteprima per app Azure servizio](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
