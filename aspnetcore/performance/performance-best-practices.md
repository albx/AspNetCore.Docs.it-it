---
title: procedure consigliate per le prestazioni di ASP.NET Core
author: mjrousos
description: Suggerimenti per aumentare le prestazioni nelle app ASP.NET Core ed evitare problemi di prestazioni comuni.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.date: 04/06/2020
no-loc:
- SignalR
uid: performance/performance-best-practices
ms.openlocfilehash: 068a35fbe410dad24030fe68c0dfd062b402212c
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977184"
---
# <a name="aspnet-core-performance-best-practices"></a><span data-ttu-id="08e58-103">procedure consigliate per le prestazioni di ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="08e58-103">ASP.NET Core Performance Best Practices</span></span>

<span data-ttu-id="08e58-104">Di [Mike Rousos](https://github.com/mjrousos)</span><span class="sxs-lookup"><span data-stu-id="08e58-104">By [Mike Rousos](https://github.com/mjrousos)</span></span>

<span data-ttu-id="08e58-105">Questo articolo fornisce linee guida per le procedure consigliate per le prestazioni con ASP.NET Core.This article provides guidelines for performance best practices with ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="08e58-105">This article provides guidelines for performance best practices with ASP.NET Core.</span></span>

## <a name="cache-aggressively"></a><span data-ttu-id="08e58-106">Memorizza nella cache in modo aggressivo</span><span class="sxs-lookup"><span data-stu-id="08e58-106">Cache aggressively</span></span>

<span data-ttu-id="08e58-107">La memorizzazione nella cache è descritta in diverse parti di questo documento.</span><span class="sxs-lookup"><span data-stu-id="08e58-107">Caching is discussed in several parts of this document.</span></span> <span data-ttu-id="08e58-108">Per altre informazioni, vedere <xref:performance/caching/response>.</span><span class="sxs-lookup"><span data-stu-id="08e58-108">For more information, see <xref:performance/caching/response>.</span></span>

## <a name="understand-hot-code-paths"></a><span data-ttu-id="08e58-109">Comprendere i percorsi dei codici attivi</span><span class="sxs-lookup"><span data-stu-id="08e58-109">Understand hot code paths</span></span>

<span data-ttu-id="08e58-110">In questo documento, un percorso di *codice attivo* è definito come un percorso di codice che viene chiamato frequentemente e in cui si verifica gran parte del tempo di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="08e58-110">In this document, a *hot code path* is defined as a code path that is frequently called and where much of the execution time occurs.</span></span> <span data-ttu-id="08e58-111">I percorsi di codice popup in genere limitano la scalabilità orizzontale e le prestazioni dell'app e vengono illustrati in diverse parti di questo documento.</span><span class="sxs-lookup"><span data-stu-id="08e58-111">Hot code paths typically limit app scale-out and performance and are discussed in several parts of this document.</span></span>

## <a name="avoid-blocking-calls"></a><span data-ttu-id="08e58-112">Evitare di bloccare le chiamate</span><span class="sxs-lookup"><span data-stu-id="08e58-112">Avoid blocking calls</span></span>

<span data-ttu-id="08e58-113">ASP.NET le app di base devono essere progettate per elaborare più richieste contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="08e58-113">ASP.NET Core apps should be designed to process many requests simultaneously.</span></span> <span data-ttu-id="08e58-114">Le API asincrone consentono a un piccolo pool di thread di gestire migliaia di richieste simultanee non attendendo chiamate di blocco.</span><span class="sxs-lookup"><span data-stu-id="08e58-114">Asynchronous APIs allow a small pool of threads to handle thousands of concurrent requests by not waiting on blocking calls.</span></span> <span data-ttu-id="08e58-115">Anziché attendere il completamento di un'attività sincrona a esecuzione prolungata, il thread può lavorare su un'altra richiesta.</span><span class="sxs-lookup"><span data-stu-id="08e58-115">Rather than waiting on a long-running synchronous task to complete, the thread can work on another request.</span></span>

<span data-ttu-id="08e58-116">Un problema di prestazioni comune nelle app ASP.NET Core è il blocco delle chiamate che potrebbero essere asincrone.</span><span class="sxs-lookup"><span data-stu-id="08e58-116">A common performance problem in ASP.NET Core apps is blocking calls that could be asynchronous.</span></span> <span data-ttu-id="08e58-117">Molte chiamate di blocco sincrone causano la fame del pool di [thread](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) e i tempi di risposta ridotti.</span><span class="sxs-lookup"><span data-stu-id="08e58-117">Many synchronous blocking calls lead to [Thread Pool starvation](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) and degraded response times.</span></span>

<span data-ttu-id="08e58-118">**Non:**</span><span class="sxs-lookup"><span data-stu-id="08e58-118">**Do not**:</span></span>

* <span data-ttu-id="08e58-119">Bloccare l'esecuzione asincrona chiamando [Task.Wait](/dotnet/api/system.threading.tasks.task.wait) o [Task.Result](/dotnet/api/system.threading.tasks.task-1.result).</span><span class="sxs-lookup"><span data-stu-id="08e58-119">Block asynchronous execution by calling [Task.Wait](/dotnet/api/system.threading.tasks.task.wait) or [Task.Result](/dotnet/api/system.threading.tasks.task-1.result).</span></span>
* <span data-ttu-id="08e58-120">Acquisire blocchi in percorsi di codice comuni.</span><span class="sxs-lookup"><span data-stu-id="08e58-120">Acquire locks in common code paths.</span></span> <span data-ttu-id="08e58-121">ASP.NET le app di base sono più performanti quando sono progettate per eseguire il codice in parallelo.</span><span class="sxs-lookup"><span data-stu-id="08e58-121">ASP.NET Core apps are most performant when architected to run code in parallel.</span></span>
* <span data-ttu-id="08e58-122">Chiamare [Task.Run](/dotnet/api/system.threading.tasks.task.run) e attenderlo immediatamente.</span><span class="sxs-lookup"><span data-stu-id="08e58-122">Call [Task.Run](/dotnet/api/system.threading.tasks.task.run) and immediately await it.</span></span> <span data-ttu-id="08e58-123">ASP.NET Core esegue già il codice dell'app nei normali thread del pool di thread, pertanto la chiamata a Task.Run comporta solo una pianificazione del pool di thread aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="08e58-123">ASP.NET Core already runs app code on normal Thread Pool threads, so calling Task.Run only results in extra unnecessary Thread Pool scheduling.</span></span> <span data-ttu-id="08e58-124">Anche se il codice pianificato bloccasse un thread, Task.Run non lo impedisce.</span><span class="sxs-lookup"><span data-stu-id="08e58-124">Even if the scheduled code would block a thread, Task.Run does not prevent that.</span></span>

<span data-ttu-id="08e58-125">**Effettuare l'operazione**:</span><span class="sxs-lookup"><span data-stu-id="08e58-125">**Do**:</span></span>

* <span data-ttu-id="08e58-126">Rendere asincroni i percorsi dei [codici attivi.](#understand-hot-code-paths)</span><span class="sxs-lookup"><span data-stu-id="08e58-126">Make [hot code paths](#understand-hot-code-paths) asynchronous.</span></span>
* <span data-ttu-id="08e58-127">Chiamare l'accesso ai dati, i/o e le operazioni a esecuzione prolungata API in modo asincrono se è disponibile un'API asincrona.</span><span class="sxs-lookup"><span data-stu-id="08e58-127">Call data access, I/O, and long-running operations APIs asynchronously if an asynchronous API is available.</span></span> <span data-ttu-id="08e58-128">**Non** usare [Task.Run](/dotnet/api/system.threading.tasks.task.run) per rendere asincrona un'API synchronus.</span><span class="sxs-lookup"><span data-stu-id="08e58-128">Do **not** use [Task.Run](/dotnet/api/system.threading.tasks.task.run) to make a synchronus API asynchronous.</span></span>
* <span data-ttu-id="08e58-129">Rendere asincrone le azioni controller/pagina Razor.Make controller/Razor Page actions asynchronous.</span><span class="sxs-lookup"><span data-stu-id="08e58-129">Make controller/Razor Page actions asynchronous.</span></span> <span data-ttu-id="08e58-130">L'intero stack di chiamate è asincrono per trarre vantaggio dai modelli [async/await.](/dotnet/csharp/programming-guide/concepts/async/)</span><span class="sxs-lookup"><span data-stu-id="08e58-130">The entire call stack is asynchronous in order to benefit from [async/await](/dotnet/csharp/programming-guide/concepts/async/) patterns.</span></span>

<span data-ttu-id="08e58-131">Un profiler, ad esempio [PerfView](https://github.com/Microsoft/perfview), può essere utilizzato per trovare i thread aggiunti frequentemente al [pool di thread](/windows/desktop/procthread/thread-pools).</span><span class="sxs-lookup"><span data-stu-id="08e58-131">A profiler, such as [PerfView](https://github.com/Microsoft/perfview), can be used to find threads frequently added to the [Thread Pool](/windows/desktop/procthread/thread-pools).</span></span> <span data-ttu-id="08e58-132">L'evento `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start` indica un thread aggiunto al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="08e58-132">The `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start` event indicates a thread added to the thread pool.</span></span> <!--  For more information, see [async guidance docs](TBD-Link_To_Davifowl_Doc)  -->

## <a name="minimize-large-object-allocations"></a><span data-ttu-id="08e58-133">Ridurre al minimo le allocazioni di oggetti di grandi dimensioni</span><span class="sxs-lookup"><span data-stu-id="08e58-133">Minimize large object allocations</span></span>

<span data-ttu-id="08e58-134">Il Garbage Collector di .NET Core gestisce automaticamente l'allocazione e il rilascio della memoria nelle app ASP.NET Core.The [.NET Core garbage collector](/dotnet/standard/garbage-collection/) manages allocation and release of memory automatically in ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="08e58-134">The [.NET Core garbage collector](/dotnet/standard/garbage-collection/) manages allocation and release of memory automatically in ASP.NET Core apps.</span></span> <span data-ttu-id="08e58-135">L'operazione di Garbage Collection automatica in genere significa che gli sviluppatori non devono preoccuparsi di come e quando la memoria viene liberata.</span><span class="sxs-lookup"><span data-stu-id="08e58-135">Automatic garbage collection generally means that developers don't need to worry about how or when memory is freed.</span></span> <span data-ttu-id="08e58-136">Tuttavia, la pulizia degli oggetti senza riferimenti richiede tempo della CPU, pertanto gli sviluppatori devono ridurre al minimo l'allocazione di oggetti nei [percorsi](#understand-hot-code-paths)di codice a caldo .</span><span class="sxs-lookup"><span data-stu-id="08e58-136">However, cleaning up unreferenced objects takes CPU time, so developers should minimize allocating objects in [hot code paths](#understand-hot-code-paths).</span></span> <span data-ttu-id="08e58-137">L'operazione di Garbage Collection è particolarmente costosa per gli oggetti di grandi dimensioni (> 85 K byte).</span><span class="sxs-lookup"><span data-stu-id="08e58-137">Garbage collection is especially expensive on large objects (> 85 K bytes).</span></span> <span data-ttu-id="08e58-138">Gli oggetti di [grandi](/dotnet/standard/garbage-collection/large-object-heap) dimensioni vengono archiviati nell'heap oggetti grandi e richiedono un'operazione di Garbage Collection completa (generazione 2) per la pulizia.</span><span class="sxs-lookup"><span data-stu-id="08e58-138">Large objects are stored on the [large object heap](/dotnet/standard/garbage-collection/large-object-heap) and require a full (generation 2) garbage collection to clean up.</span></span> <span data-ttu-id="08e58-139">A differenza delle raccolte di generazione 0 e di generazione 1, una raccolta di generazione 2 richiede una sospensione temporanea dell'esecuzione dell'app.</span><span class="sxs-lookup"><span data-stu-id="08e58-139">Unlike generation 0 and generation 1 collections, a generation 2 collection requires a temporary suspension of app execution.</span></span> <span data-ttu-id="08e58-140">L'allocazione frequente e la deallocazione di oggetti di grandi dimensioni possono causare prestazioni incoerenti.</span><span class="sxs-lookup"><span data-stu-id="08e58-140">Frequent allocation and de-allocation of large objects can cause inconsistent performance.</span></span>

<span data-ttu-id="08e58-141">Consigli:</span><span class="sxs-lookup"><span data-stu-id="08e58-141">Recommendations:</span></span>

* <span data-ttu-id="08e58-142">**Prendere** in considerazione la memorizzazione nella cache di oggetti di grandi dimensioni che vengono utilizzati di frequente.</span><span class="sxs-lookup"><span data-stu-id="08e58-142">**Do** consider caching large objects that are frequently used.</span></span> <span data-ttu-id="08e58-143">La memorizzazione nella cache di oggetti di grandi dimensioni impedisce allocazioni costose.</span><span class="sxs-lookup"><span data-stu-id="08e58-143">Caching large objects prevents expensive allocations.</span></span>
* <span data-ttu-id="08e58-144">**Eseguire** pool buffer utilizzando [un\<ArrayPool T>](/dotnet/api/system.buffers.arraypool-1) per archiviare matrici di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="08e58-144">**Do** pool buffers by using an [ArrayPool\<T>](/dotnet/api/system.buffers.arraypool-1) to store large arrays.</span></span>
* <span data-ttu-id="08e58-145">**Non** allocare molti oggetti di grandi dimensioni di breve durata nei [percorsi di codice caldo](#understand-hot-code-paths).</span><span class="sxs-lookup"><span data-stu-id="08e58-145">**Do not** allocate many, short-lived large objects on [hot code paths](#understand-hot-code-paths).</span></span>

<span data-ttu-id="08e58-146">Problemi di memoria, ad esempio il precedente, può essere diagnosticato esaminando le statistiche di garbage collection (GC) in PerfView ed esaminando:Memory issues, such as the preceding, can be diagnosed by reviewing garbage collection (GC) stats in [PerfView](https://github.com/Microsoft/perfview) and examining:</span><span class="sxs-lookup"><span data-stu-id="08e58-146">Memory issues, such as the preceding, can be diagnosed by reviewing garbage collection (GC) stats in [PerfView](https://github.com/Microsoft/perfview) and examining:</span></span>

* <span data-ttu-id="08e58-147">Tempo di pausa Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="08e58-147">Garbage collection pause time.</span></span>
* <span data-ttu-id="08e58-148">Percentuale del tempo del processore impiegato per l'operazione di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="08e58-148">What percentage of the processor time is spent in garbage collection.</span></span>
* <span data-ttu-id="08e58-149">Il numero di operazioni di Garbage Collection di generazione 0, 1 e 2.How many garbage collections are generation 0, 1, and 2.</span><span class="sxs-lookup"><span data-stu-id="08e58-149">How many garbage collections are generation 0, 1, and 2.</span></span>

<span data-ttu-id="08e58-150">Per ulteriori informazioni, vedere [Garbage Collection e prestazioni](/dotnet/standard/garbage-collection/performance).</span><span class="sxs-lookup"><span data-stu-id="08e58-150">For more information, see [Garbage Collection and Performance](/dotnet/standard/garbage-collection/performance).</span></span>

## <a name="optimize-data-access-and-io"></a><span data-ttu-id="08e58-151">Ottimizzare l'accesso ai dati e l'I/OOptimize data access and I/O</span><span class="sxs-lookup"><span data-stu-id="08e58-151">Optimize data access and I/O</span></span>

<span data-ttu-id="08e58-152">Le interazioni con un archivio dati e altri servizi remoti sono spesso le parti più lente di un'app ASP.NET Core.Interactions with a data store and other remote services are often the slowest parts of an ASP.NET Core app.</span><span class="sxs-lookup"><span data-stu-id="08e58-152">Interactions with a data store and other remote services are often the slowest parts of an ASP.NET Core app.</span></span> <span data-ttu-id="08e58-153">La lettura e la scrittura efficiente dei dati è fondamentale per ottenere buone prestazioni.</span><span class="sxs-lookup"><span data-stu-id="08e58-153">Reading and writing data efficiently is critical for good performance.</span></span>

<span data-ttu-id="08e58-154">Consigli:</span><span class="sxs-lookup"><span data-stu-id="08e58-154">Recommendations:</span></span>

* <span data-ttu-id="08e58-155">**Chiamare** tutte le API di accesso ai dati in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="08e58-155">**Do** call all data access APIs asynchronously.</span></span>
* <span data-ttu-id="08e58-156">**Non** recuperare più dati del necessario.</span><span class="sxs-lookup"><span data-stu-id="08e58-156">**Do not** retrieve more data than is necessary.</span></span> <span data-ttu-id="08e58-157">Scrivere query per restituire solo i dati necessari per la richiesta HTTP corrente.</span><span class="sxs-lookup"><span data-stu-id="08e58-157">Write queries to return just the data that's necessary for the current HTTP request.</span></span>
* <span data-ttu-id="08e58-158">**Prendere** in considerazione la memorizzazione nella cache dei dati a cui si accede di frequente recuperati da un database o da un servizio remoto se i dati leggermente obsoleti sono accettabili.</span><span class="sxs-lookup"><span data-stu-id="08e58-158">**Do** consider caching frequently accessed data retrieved from a database or remote service if slightly out-of-date data is acceptable.</span></span> <span data-ttu-id="08e58-159">A seconda dello scenario, utilizzare un [MemoryCache](xref:performance/caching/memory) o un [DistributedCache](xref:performance/caching/distributed).</span><span class="sxs-lookup"><span data-stu-id="08e58-159">Depending on the scenario, use a [MemoryCache](xref:performance/caching/memory) or a [DistributedCache](xref:performance/caching/distributed).</span></span> <span data-ttu-id="08e58-160">Per altre informazioni, vedere <xref:performance/caching/response>.</span><span class="sxs-lookup"><span data-stu-id="08e58-160">For more information, see <xref:performance/caching/response>.</span></span>
* <span data-ttu-id="08e58-161">**Riduci** al minimo i round trip di rete.</span><span class="sxs-lookup"><span data-stu-id="08e58-161">**Do** minimize network round trips.</span></span> <span data-ttu-id="08e58-162">L'obiettivo è recuperare i dati richiesti in una singola chiamata anziché più chiamate.</span><span class="sxs-lookup"><span data-stu-id="08e58-162">The goal is to retrieve the required data in a single call rather than several calls.</span></span>
* <span data-ttu-id="08e58-163">**Utilizzare** [query senza rilevamento](/ef/core/querying/tracking#no-tracking-queries) in Entity Framework Core quando si accede ai dati per scopi di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="08e58-163">**Do** use [no-tracking queries](/ef/core/querying/tracking#no-tracking-queries) in Entity Framework Core when accessing data for read-only purposes.</span></span> <span data-ttu-id="08e58-164">EF Core può restituire i risultati delle query senza rilevamento in modo più efficiente.</span><span class="sxs-lookup"><span data-stu-id="08e58-164">EF Core can return the results of no-tracking queries more efficiently.</span></span>
* <span data-ttu-id="08e58-165">**Filtrare** e aggregare `.Where` `.Select`le `.Sum` query LINQ (ad esempio, con istruzioni , o , ) in modo che il filtro venga eseguito dal database.</span><span class="sxs-lookup"><span data-stu-id="08e58-165">**Do** filter and aggregate LINQ queries (with `.Where`, `.Select`, or `.Sum` statements, for example) so that the filtering is performed by the database.</span></span>
* <span data-ttu-id="08e58-166">**Si** consideri che EF Core risolve alcuni operatori di query sul client, che può portare a esecuzione di query inefficiente.</span><span class="sxs-lookup"><span data-stu-id="08e58-166">**Do** consider that EF Core resolves some query operators on the client, which may lead to inefficient query execution.</span></span> <span data-ttu-id="08e58-167">Per ulteriori informazioni, vedere [Problemi di prestazioni](/ef/core/querying/client-eval#client-evaluation-performance-issues)di valutazione client .</span><span class="sxs-lookup"><span data-stu-id="08e58-167">For more information, see [Client evaluation performance issues](/ef/core/querying/client-eval#client-evaluation-performance-issues).</span></span>
* <span data-ttu-id="08e58-168">**Non** utilizzare query di proiezione sulle raccolte, il che può comportare l'esecuzione di query SQL "N e 1".</span><span class="sxs-lookup"><span data-stu-id="08e58-168">**Do not** use projection queries on collections, which can result in executing "N + 1" SQL queries.</span></span> <span data-ttu-id="08e58-169">Per ulteriori informazioni, vedere [Ottimizzazione delle sottoquery correlate](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).</span><span class="sxs-lookup"><span data-stu-id="08e58-169">For more information, see [Optimization of correlated subqueries](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).</span></span>

<span data-ttu-id="08e58-170">Vedere EF High Performance per gli approcci che possono migliorare le prestazioni nelle app su larga scala:See [EF High Performance](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) for approaches that may improve performance in high-scale apps:</span><span class="sxs-lookup"><span data-stu-id="08e58-170">See [EF High Performance](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) for approaches that may improve performance in high-scale apps:</span></span>

* [<span data-ttu-id="08e58-171">Pooling DbContext</span><span class="sxs-lookup"><span data-stu-id="08e58-171">DbContext pooling</span></span>](/ef/core/what-is-new/ef-core-2.0#dbcontext-pooling)
* [<span data-ttu-id="08e58-172">Query compilate esplicite</span><span class="sxs-lookup"><span data-stu-id="08e58-172">Explicitly compiled queries</span></span>](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries)

<span data-ttu-id="08e58-173">È consigliabile misurare l'impatto degli approcci ad alte prestazioni precedenti prima di eseguire il commit della base di codice.</span><span class="sxs-lookup"><span data-stu-id="08e58-173">We recommend measuring the impact of the preceding high-performance approaches before committing the code base.</span></span> <span data-ttu-id="08e58-174">La complessità aggiuntiva delle query compilate potrebbe non giustificare il miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="08e58-174">The additional complexity of compiled queries may not justify the performance improvement.</span></span>

<span data-ttu-id="08e58-175">I problemi relativi alle query possono essere rilevati esaminando il tempo impiegato per accedere ai dati con [Application Insights](/azure/application-insights/app-insights-overview) o con gli strumenti di profilatura.</span><span class="sxs-lookup"><span data-stu-id="08e58-175">Query issues can be detected by reviewing the time spent accessing data with [Application Insights](/azure/application-insights/app-insights-overview) or with profiling tools.</span></span> <span data-ttu-id="08e58-176">La maggior parte dei database rende inoltre disponibili statistiche relative alle query eseguite di frequente.</span><span class="sxs-lookup"><span data-stu-id="08e58-176">Most databases also make statistics available concerning frequently executed queries.</span></span>

## <a name="pool-http-connections-with-httpclientfactory"></a><span data-ttu-id="08e58-177">Pool di connessioni HTTP con HttpClientFactory</span><span class="sxs-lookup"><span data-stu-id="08e58-177">Pool HTTP connections with HttpClientFactory</span></span>

<span data-ttu-id="08e58-178">Sebbene [HttpClient](/dotnet/api/system.net.http.httpclient) implementi l'interfaccia, `IDisposable` è progettata per il riutilizzo.</span><span class="sxs-lookup"><span data-stu-id="08e58-178">Although [HttpClient](/dotnet/api/system.net.http.httpclient) implements the `IDisposable` interface, it's designed for reuse.</span></span> <span data-ttu-id="08e58-179">Le `HttpClient` istanze chiuse lasciano `TIME_WAIT` le prese aperte nello stato per un breve periodo di tempo.</span><span class="sxs-lookup"><span data-stu-id="08e58-179">Closed `HttpClient` instances leave sockets open in the `TIME_WAIT` state for a short period of time.</span></span> <span data-ttu-id="08e58-180">Se viene usato frequentemente un `HttpClient` percorso di codice che crea ed elimina gli oggetti, l'app potrebbe esaurire i socket disponibili.</span><span class="sxs-lookup"><span data-stu-id="08e58-180">If a code path that creates and disposes of `HttpClient` objects is frequently used, the app may exhaust available sockets.</span></span> <span data-ttu-id="08e58-181">[HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) è stato introdotto in ASP.NET Core 2.1 come soluzione a questo problema.</span><span class="sxs-lookup"><span data-stu-id="08e58-181">[HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) was introduced in ASP.NET Core 2.1 as a solution to this problem.</span></span> <span data-ttu-id="08e58-182">Gestisce il pooling delle connessioni HTTP per ottimizzare le prestazioni e l'affidabilità.</span><span class="sxs-lookup"><span data-stu-id="08e58-182">It handles pooling HTTP connections to optimize performance and reliability.</span></span>

<span data-ttu-id="08e58-183">Consigli:</span><span class="sxs-lookup"><span data-stu-id="08e58-183">Recommendations:</span></span>

* <span data-ttu-id="08e58-184">**Non** creare ed `HttpClient` eliminare direttamente le istanze.</span><span class="sxs-lookup"><span data-stu-id="08e58-184">**Do not** create and dispose of `HttpClient` instances directly.</span></span>
* <span data-ttu-id="08e58-185">**Utilizzare** [HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) per `HttpClient` recuperare le istanze.</span><span class="sxs-lookup"><span data-stu-id="08e58-185">**Do** use [HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) to retrieve `HttpClient` instances.</span></span> <span data-ttu-id="08e58-186">Per ulteriori informazioni, vedere [Usare HttpClientFactory per implementare richieste HTTP resilienti.](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)</span><span class="sxs-lookup"><span data-stu-id="08e58-186">For more information, see [Use HttpClientFactory to implement resilient HTTP requests](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests).</span></span>

## <a name="keep-common-code-paths-fast"></a><span data-ttu-id="08e58-187">Mantenere veloci i percorsi di codice comuni</span><span class="sxs-lookup"><span data-stu-id="08e58-187">Keep common code paths fast</span></span>

<span data-ttu-id="08e58-188">Si desidera che tutto il codice sia veloce.</span><span class="sxs-lookup"><span data-stu-id="08e58-188">You want all of your code to be fast.</span></span> <span data-ttu-id="08e58-189">I percorsi di codice più chiamati di frequente sono i più critici da ottimizzare.</span><span class="sxs-lookup"><span data-stu-id="08e58-189">Frequently-called code paths are the most critical to optimize.</span></span> <span data-ttu-id="08e58-190">incluse le seguenti:</span><span class="sxs-lookup"><span data-stu-id="08e58-190">These include:</span></span>

* <span data-ttu-id="08e58-191">I componenti middleware nella pipeline di elaborazione delle richieste dell'app, in particolare il middleware vengono eseguiti nelle prime fasi della pipeline.</span><span class="sxs-lookup"><span data-stu-id="08e58-191">Middleware components in the app's request processing pipeline, especially middleware run early in the pipeline.</span></span> <span data-ttu-id="08e58-192">Questi componenti hanno un grande impatto sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="08e58-192">These components have a large impact on performance.</span></span>
* <span data-ttu-id="08e58-193">Codice eseguito per ogni richiesta o più volte per richiesta.</span><span class="sxs-lookup"><span data-stu-id="08e58-193">Code that's executed for every request or multiple times per request.</span></span> <span data-ttu-id="08e58-194">Ad esempio, la registrazione personalizzata, i gestori di autorizzazioni o l'inizializzazione di servizi temporanei.</span><span class="sxs-lookup"><span data-stu-id="08e58-194">For example, custom logging, authorization handlers, or initialization of transient services.</span></span>

<span data-ttu-id="08e58-195">Consigli:</span><span class="sxs-lookup"><span data-stu-id="08e58-195">Recommendations:</span></span>

* <span data-ttu-id="08e58-196">**Non** utilizzare componenti middleware personalizzati con attività a esecuzione prolungata.</span><span class="sxs-lookup"><span data-stu-id="08e58-196">**Do not** use custom middleware components with long-running tasks.</span></span>
* <span data-ttu-id="08e58-197">**Utilizzare** gli strumenti di profilatura delle prestazioni, ad esempio [Visual Studio Diagnostic Tools](/visualstudio/profiling/profiling-feature-tour) o [PerfView](https://github.com/Microsoft/perfview), per identificare i percorsi del [codice di interfaccia utente.](#understand-hot-code-paths)</span><span class="sxs-lookup"><span data-stu-id="08e58-197">**Do** use performance profiling tools, such as [Visual Studio Diagnostic Tools](/visualstudio/profiling/profiling-feature-tour) or [PerfView](https://github.com/Microsoft/perfview)), to identify [hot code paths](#understand-hot-code-paths).</span></span>

## <a name="complete-long-running-tasks-outside-of-http-requests"></a><span data-ttu-id="08e58-198">Completare le attività a esecuzione prolungata all'esterno delle richieste HTTPComplete long-running Tasks outside of HTTP requests</span><span class="sxs-lookup"><span data-stu-id="08e58-198">Complete long-running Tasks outside of HTTP requests</span></span>

<span data-ttu-id="08e58-199">La maggior parte delle richieste a un'app ASP.NET Core può essere gestita da un controller o da un modello di pagina che chiama i servizi necessari e restituisce una risposta HTTP.</span><span class="sxs-lookup"><span data-stu-id="08e58-199">Most requests to an ASP.NET Core app can be handled by a controller or page model calling necessary services and returning an HTTP response.</span></span> <span data-ttu-id="08e58-200">Per alcune richieste che coinvolgono attività a esecuzione prolungata, è preferibile rendere asincrono l'intero processo di richiesta-risposta.</span><span class="sxs-lookup"><span data-stu-id="08e58-200">For some requests that involve long-running tasks, it's better to make the entire request-response process asynchronous.</span></span>

<span data-ttu-id="08e58-201">Consigli:</span><span class="sxs-lookup"><span data-stu-id="08e58-201">Recommendations:</span></span>

* <span data-ttu-id="08e58-202">**Non** attendere il completamento delle attività a esecuzione prolungata come parte della normale elaborazione delle richieste HTTP.</span><span class="sxs-lookup"><span data-stu-id="08e58-202">**Do not** wait for long-running tasks to complete as part of ordinary HTTP request processing.</span></span>
* <span data-ttu-id="08e58-203">**Valutare** la possibilità di gestire le richieste a esecuzione prolungata con [servizi in background](xref:fundamentals/host/hosted-services) o fuori processo con una funzione di [Azure.](/azure/azure-functions/)</span><span class="sxs-lookup"><span data-stu-id="08e58-203">**Do** consider handling long-running requests with [background services](xref:fundamentals/host/hosted-services) or out of process with an [Azure Function](/azure/azure-functions/).</span></span> <span data-ttu-id="08e58-204">Il completamento del lavoro out-of-process è particolarmente utile per le attività che richiedono un uso intensivo della CPU.</span><span class="sxs-lookup"><span data-stu-id="08e58-204">Completing work out-of-process is especially beneficial for CPU-intensive tasks.</span></span>
* <span data-ttu-id="08e58-205">**Utilizzare** le opzioni di comunicazione [SignalR](xref:signalr/introduction)in tempo reale, ad esempio , per comunicare con i client in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="08e58-205">**Do** use real-time communication options, such as [SignalR](xref:signalr/introduction), to communicate with clients asynchronously.</span></span>

## <a name="minify-client-assets"></a><span data-ttu-id="08e58-206">Riduci le risorse dei clienti</span><span class="sxs-lookup"><span data-stu-id="08e58-206">Minify client assets</span></span>

<span data-ttu-id="08e58-207">ASP.NET le app di base con front-end complessi spesso servono molti file JavaScript, CSS o di immagine.</span><span class="sxs-lookup"><span data-stu-id="08e58-207">ASP.NET Core apps with complex front-ends frequently serve many JavaScript, CSS, or image files.</span></span> <span data-ttu-id="08e58-208">Le prestazioni delle richieste di carico iniziali possono essere migliorate:</span><span class="sxs-lookup"><span data-stu-id="08e58-208">Performance of initial load requests can be improved by:</span></span>

* <span data-ttu-id="08e58-209">Bundling, che combina più file in uno.</span><span class="sxs-lookup"><span data-stu-id="08e58-209">Bundling, which combines multiple files into one.</span></span>
* <span data-ttu-id="08e58-210">Riduzione al più possibile, che riduce le dimensioni dei file rimuovendo spazi vuoti e commenti.</span><span class="sxs-lookup"><span data-stu-id="08e58-210">Minifying, which reduces the size of files by removing whitespace and comments.</span></span>

<span data-ttu-id="08e58-211">Consigli:</span><span class="sxs-lookup"><span data-stu-id="08e58-211">Recommendations:</span></span>

* <span data-ttu-id="08e58-212">**Utilizzare** ASP.NET supporto [incorporato](xref:client-side/bundling-and-minification) di Core per l'aggregazione e la minimizzazione delle risorse client.</span><span class="sxs-lookup"><span data-stu-id="08e58-212">**Do** use ASP.NET Core's [built-in support](xref:client-side/bundling-and-minification) for bundling and minifying client assets.</span></span>
* <span data-ttu-id="08e58-213">**Prendere** in considerazione altri strumenti di terze parti, ad esempio [Webpack](https://webpack.js.org/), per la gestione complessa delle risorse client.</span><span class="sxs-lookup"><span data-stu-id="08e58-213">**Do** consider other third-party tools, such as [Webpack](https://webpack.js.org/), for complex client asset management.</span></span>

## <a name="compress-responses"></a><span data-ttu-id="08e58-214">Comprimere le risposte</span><span class="sxs-lookup"><span data-stu-id="08e58-214">Compress responses</span></span>

 <span data-ttu-id="08e58-215">La riduzione delle dimensioni della risposta di solito aumenta la velocità di risposta di un'app, spesso in modo drammatico.</span><span class="sxs-lookup"><span data-stu-id="08e58-215">Reducing the size of the response usually increases the responsiveness of an app, often dramatically.</span></span> <span data-ttu-id="08e58-216">Un modo per ridurre le dimensioni del payload consiste nel comprimere le risposte di un'app.</span><span class="sxs-lookup"><span data-stu-id="08e58-216">One way to reduce payload sizes is to compress an app's responses.</span></span> <span data-ttu-id="08e58-217">Per ulteriori informazioni, consultate [Compressione delle risposte.](xref:performance/response-compression)</span><span class="sxs-lookup"><span data-stu-id="08e58-217">For more information, see [Response compression](xref:performance/response-compression).</span></span>

## <a name="use-the-latest-aspnet-core-release"></a><span data-ttu-id="08e58-218">Usare la versione più recente di ASP.NET CoreUse the latest ASP.NET Core release</span><span class="sxs-lookup"><span data-stu-id="08e58-218">Use the latest ASP.NET Core release</span></span>

<span data-ttu-id="08e58-219">Ogni nuova versione di ASP.NET Core include miglioramenti delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="08e58-219">Each new release of ASP.NET Core includes performance improvements.</span></span> <span data-ttu-id="08e58-220">Le ottimizzazioni in .NET Core e ASP.NET Core indicano che le versioni più recenti in genere superano le versioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="08e58-220">Optimizations in .NET Core and ASP.NET Core mean that newer versions generally outperform older versions.</span></span> <span data-ttu-id="08e58-221">Ad esempio, .NET Core 2.1 ha aggiunto il supporto per le espressioni regolari compilate e ha beneficiato di [Span\<T>](https://msdn.microsoft.com/magazine/mt814808.aspx).</span><span class="sxs-lookup"><span data-stu-id="08e58-221">For example, .NET Core 2.1 added support for compiled regular expressions and benefitted from [Span\<T>](https://msdn.microsoft.com/magazine/mt814808.aspx).</span></span> <span data-ttu-id="08e58-222">ASP.NET Core 2.2 added support for HTTP/2.</span><span class="sxs-lookup"><span data-stu-id="08e58-222">ASP.NET Core 2.2 added support for HTTP/2.</span></span> <span data-ttu-id="08e58-223">[ASP.NET Core 3.0 aggiunge molti miglioramenti](xref:aspnetcore-3.0) che riducono l'utilizzo della memoria e migliorano la velocità effettiva.</span><span class="sxs-lookup"><span data-stu-id="08e58-223">[ASP.NET Core 3.0 adds many improvements](xref:aspnetcore-3.0) that reduce memory usage and improve throughput.</span></span> <span data-ttu-id="08e58-224">Se le prestazioni sono una priorità, prendere in considerazione l'aggiornamento alla versione corrente di ASP.NET Core.If performance is a priority, consider upgrading to the current version of ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="08e58-224">If performance is a priority, consider upgrading to the current version of ASP.NET Core.</span></span>

## <a name="minimize-exceptions"></a><span data-ttu-id="08e58-225">Ridurre al minimo le eccezioni</span><span class="sxs-lookup"><span data-stu-id="08e58-225">Minimize exceptions</span></span>

<span data-ttu-id="08e58-226">Le eccezioni dovrebbero essere rare.</span><span class="sxs-lookup"><span data-stu-id="08e58-226">Exceptions should be rare.</span></span> <span data-ttu-id="08e58-227">La generazione e l'intercettazione di eccezioni è lenta rispetto ad altri modelli di flusso di codice.</span><span class="sxs-lookup"><span data-stu-id="08e58-227">Throwing and catching exceptions is slow relative to other code flow patterns.</span></span> <span data-ttu-id="08e58-228">Per questo motivo, le eccezioni non devono essere utilizzate per controllare il normale flusso del programma.</span><span class="sxs-lookup"><span data-stu-id="08e58-228">Because of this, exceptions shouldn't be used to control normal program flow.</span></span>

<span data-ttu-id="08e58-229">Consigli:</span><span class="sxs-lookup"><span data-stu-id="08e58-229">Recommendations:</span></span>

* <span data-ttu-id="08e58-230">**Non** utilizzare la generazione o l'intercettazione di eccezioni come mezzo del normale flusso di programma, in particolare nei [percorsi](#understand-hot-code-paths)di codice a caldo .</span><span class="sxs-lookup"><span data-stu-id="08e58-230">**Do not** use throwing or catching exceptions as a means of normal program flow, especially in [hot code paths](#understand-hot-code-paths).</span></span>
* <span data-ttu-id="08e58-231">**Includere** la logica nell'app per rilevare e gestire le condizioni che potrebbero causare un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="08e58-231">**Do** include logic in the app to detect and handle conditions that would cause an exception.</span></span>
* <span data-ttu-id="08e58-232">**Generare** o intercettare eccezioni per condizioni insolite o impreviste.</span><span class="sxs-lookup"><span data-stu-id="08e58-232">**Do** throw or catch exceptions for unusual or unexpected conditions.</span></span>

<span data-ttu-id="08e58-233">Gli strumenti di diagnostica delle app, ad esempio Application Insights, consentono di identificare le eccezioni comuni in un'app che possono influire sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="08e58-233">App diagnostic tools, such as Application Insights, can help to identify common exceptions in an app that may affect performance.</span></span>

## <a name="performance-and-reliability"></a><span data-ttu-id="08e58-234">Prestazioni e affidabilità</span><span class="sxs-lookup"><span data-stu-id="08e58-234">Performance and reliability</span></span>

<span data-ttu-id="08e58-235">Nelle sezioni seguenti vengono forniti suggerimenti sulle prestazioni e problemi e soluzioni noti relativi all'affidabilità.</span><span class="sxs-lookup"><span data-stu-id="08e58-235">The following sections provide performance tips and known reliability problems and solutions.</span></span>

## <a name="avoid-synchronous-read-or-write-on-httprequesthttpresponse-body"></a><span data-ttu-id="08e58-236">Evitare la lettura o la scrittura sincrona nel corpo HttpRequest/HttpResponseAvoid synchronous read or write on HttpRequest/HttpResponse body</span><span class="sxs-lookup"><span data-stu-id="08e58-236">Avoid synchronous read or write on HttpRequest/HttpResponse body</span></span>

<span data-ttu-id="08e58-237">Tutti i / o in ASP.NET Core è asincrono.</span><span class="sxs-lookup"><span data-stu-id="08e58-237">All I/O in ASP.NET Core is asynchronous.</span></span> <span data-ttu-id="08e58-238">I server `Stream` implementano l'interfaccia, che dispone di overload sia sincroni che asincroni.</span><span class="sxs-lookup"><span data-stu-id="08e58-238">Servers implement the `Stream` interface, which has both synchronous and asynchronous overloads.</span></span> <span data-ttu-id="08e58-239">Quelli asincroni dovrebbero essere preferiti per evitare di bloccare i thread del pool di thread.</span><span class="sxs-lookup"><span data-stu-id="08e58-239">The asynchronous ones should be preferred to avoid blocking thread pool threads.</span></span> <span data-ttu-id="08e58-240">Il blocco dei thread può causare la fame del pool di thread.</span><span class="sxs-lookup"><span data-stu-id="08e58-240">Blocking threads can lead to thread pool starvation.</span></span>

<span data-ttu-id="08e58-241">**Non eseguire questa operazione:** Nell'esempio riportato di seguito viene utilizzato l'oggetto <xref:System.IO.StreamReader.ReadToEnd*>.</span><span class="sxs-lookup"><span data-stu-id="08e58-241">**Do not do this:** The following example uses the <xref:System.IO.StreamReader.ReadToEnd*>.</span></span> <span data-ttu-id="08e58-242">Blocca il thread corrente per attendere il risultato.</span><span class="sxs-lookup"><span data-stu-id="08e58-242">It blocks the current thread to wait for the result.</span></span> <span data-ttu-id="08e58-243">Questo è un esempio di [sincronizzazione su async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
).</span><span class="sxs-lookup"><span data-stu-id="08e58-243">This is an example of [sync over async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
).</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet1)]

<span data-ttu-id="08e58-244">Nel codice precedente, `Get` legge in modo sincrono l'intero corpo della richiesta HTTP in memoria.</span><span class="sxs-lookup"><span data-stu-id="08e58-244">In the preceding code, `Get` synchronously reads the entire HTTP request body into memory.</span></span> <span data-ttu-id="08e58-245">Se il client viene caricato lentamente, l'app esegue la sincronizzazione tramite async.</span><span class="sxs-lookup"><span data-stu-id="08e58-245">If the client is slowly uploading, the app is doing sync over async.</span></span> <span data-ttu-id="08e58-246">L'app esegue la sincronizzazione tramite async perché Kestrel **NON** supporta letture sincrone.</span><span class="sxs-lookup"><span data-stu-id="08e58-246">The app does sync over async because Kestrel does **NOT** support synchronous reads.</span></span>

<span data-ttu-id="08e58-247">**Procedere come segue:** Nell'esempio <xref:System.IO.StreamReader.ReadToEndAsync*> seguente viene utilizzato e non viene bloccato il thread durante la lettura.</span><span class="sxs-lookup"><span data-stu-id="08e58-247">**Do this:** The following example uses <xref:System.IO.StreamReader.ReadToEndAsync*> and does not block the thread while reading.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet2)]

<span data-ttu-id="08e58-248">Il codice precedente legge in modo asincrono l'intero corpo della richiesta HTTP in memoria.</span><span class="sxs-lookup"><span data-stu-id="08e58-248">The preceding code asynchronously reads the entire HTTP request body into memory.</span></span>

> [!WARNING]
> <span data-ttu-id="08e58-249">Se la richiesta è di grandi dimensioni, la lettura dell'intero corpo della richiesta HTTP in memoria potrebbe causare una condizione di memoria insufficiente.If the request is large, reading the entire HTTP request body in memory could lead to an out memory (OOM) condition.</span><span class="sxs-lookup"><span data-stu-id="08e58-249">If the request is large, reading the entire HTTP request body into memory could lead to an out of memory (OOM) condition.</span></span> <span data-ttu-id="08e58-250">OOM può comportare una negazione del servizio.</span><span class="sxs-lookup"><span data-stu-id="08e58-250">OOM can result in a Denial Of Service.</span></span>  <span data-ttu-id="08e58-251">Per altre informazioni, vedere Evitare di [leggere corpi di richiesta di grandi dimensioni o corpi di risposta in memoria](#arlb) in questo documento.</span><span class="sxs-lookup"><span data-stu-id="08e58-251">For more information, see [Avoid reading large request bodies or response bodies into memory](#arlb) in this document.</span></span>

<span data-ttu-id="08e58-252">**Procedere come segue:** L'esempio seguente è completamente asincrono usando un corpo della richiesta non memorizzato nel buffer:The following example is fully asynchronous using a non buffered request body:</span><span class="sxs-lookup"><span data-stu-id="08e58-252">**Do this:** The following example is fully asynchronous using a non buffered request body:</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet3)]

<span data-ttu-id="08e58-253">Il codice precedente deserializza in modo asincrono il corpo della richiesta in un oggetto c'è.</span><span class="sxs-lookup"><span data-stu-id="08e58-253">The preceding code asynchronously de-serializes the request body into a C# object.</span></span>

## <a name="prefer-readformasync-over-requestform"></a><span data-ttu-id="08e58-254">Preferisci ReadFormAsync rispetto a Request.Form</span><span class="sxs-lookup"><span data-stu-id="08e58-254">Prefer ReadFormAsync over Request.Form</span></span>

<span data-ttu-id="08e58-255">Usare `HttpContext.Request.ReadFormAsync` anziché `HttpContext.Request.Form`.</span><span class="sxs-lookup"><span data-stu-id="08e58-255">Use `HttpContext.Request.ReadFormAsync` instead of `HttpContext.Request.Form`.</span></span>
<span data-ttu-id="08e58-256">`HttpContext.Request.Form`può essere letto in modo sicuro solo con le seguenti condizioni:</span><span class="sxs-lookup"><span data-stu-id="08e58-256">`HttpContext.Request.Form` can be safely read only with the following conditions:</span></span>

* <span data-ttu-id="08e58-257">Il modulo è stato letto `ReadFormAsync`da una chiamata a ,</span><span class="sxs-lookup"><span data-stu-id="08e58-257">The form has been read by a call to `ReadFormAsync`, and</span></span>
* <span data-ttu-id="08e58-258">Il valore del modulo memorizzato nella cache viene letto utilizzando`HttpContext.Request.Form`</span><span class="sxs-lookup"><span data-stu-id="08e58-258">The cached form value is being read using `HttpContext.Request.Form`</span></span>

<span data-ttu-id="08e58-259">**Non eseguire questa operazione:** Nell'esempio `HttpContext.Request.Form`riportato di seguito viene utilizzato .</span><span class="sxs-lookup"><span data-stu-id="08e58-259">**Do not do this:** The following example uses `HttpContext.Request.Form`.</span></span>  <span data-ttu-id="08e58-260">`HttpContext.Request.Form`utilizza [la sincronizzazione su async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
) e può portare alla fame del pool di thread.</span><span class="sxs-lookup"><span data-stu-id="08e58-260">`HttpContext.Request.Form` uses [sync over async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
) and can lead to thread pool starvation.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet1)]

<span data-ttu-id="08e58-261">**Procedere come segue:** Nell'esempio `HttpContext.Request.ReadFormAsync` riportato di seguito viene utilizzato per leggere il corpo del form in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="08e58-261">**Do this:** The following example uses `HttpContext.Request.ReadFormAsync` to read the form body asynchronously.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet2)]

<a name="arlb"></a>

## <a name="avoid-reading-large-request-bodies-or-response-bodies-into-memory"></a><span data-ttu-id="08e58-262">Evitare di leggere corpi di richiesta di grandi dimensioni o corpi di risposta in memoria</span><span class="sxs-lookup"><span data-stu-id="08e58-262">Avoid reading large request bodies or response bodies into memory</span></span>

<span data-ttu-id="08e58-263">In .NET ogni allocazione di oggetti superiore a 85 KB finisce nell'heap oggetti grandi ([LOH](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)).</span><span class="sxs-lookup"><span data-stu-id="08e58-263">In .NET, every object allocation greater than 85 KB ends up in the large object heap ([LOH](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)).</span></span> <span data-ttu-id="08e58-264">Gli oggetti di grandi dimensioni sono costosi in due modi:</span><span class="sxs-lookup"><span data-stu-id="08e58-264">Large objects are expensive in two ways:</span></span>

* <span data-ttu-id="08e58-265">Il costo di allocazione è elevato perché la memoria per un oggetto di grandi dimensioni appena allocato deve essere cancellata.</span><span class="sxs-lookup"><span data-stu-id="08e58-265">The allocation cost is high because the memory for a newly allocated large object has to be cleared.</span></span> <span data-ttu-id="08e58-266">CLR garantisce che la memoria per tutti gli oggetti appena allocati venga cancellata.</span><span class="sxs-lookup"><span data-stu-id="08e58-266">The CLR guarantees that memory for all newly allocated objects is cleared.</span></span>
* <span data-ttu-id="08e58-267">LOH viene raccolto con il resto del mucchio.</span><span class="sxs-lookup"><span data-stu-id="08e58-267">LOH is collected with the rest of the heap.</span></span> <span data-ttu-id="08e58-268">LOH richiede [un'operazione](/dotnet/standard/garbage-collection/fundamentals) di Garbage Collection completa o [Un'insieme Gen2](/dotnet/standard/garbage-collection/fundamentals#generations).</span><span class="sxs-lookup"><span data-stu-id="08e58-268">LOH requires a full [garbage collection](/dotnet/standard/garbage-collection/fundamentals) or [Gen2 collection](/dotnet/standard/garbage-collection/fundamentals#generations).</span></span>

<span data-ttu-id="08e58-269">Questo post di [blog](https://adamsitnik.com/Array-Pool/#the-problem) descrive il problema in modo conciso:</span><span class="sxs-lookup"><span data-stu-id="08e58-269">This [blog post](https://adamsitnik.com/Array-Pool/#the-problem) describes the problem succinctly:</span></span>

> <span data-ttu-id="08e58-270">Quando un oggetto di grandi dimensioni viene allocato, viene contrassegnato come oggetto Gen 2.When a large object is allocated, it's marked as Gen 2 object.</span><span class="sxs-lookup"><span data-stu-id="08e58-270">When a large object is allocated, it's marked as Gen 2 object.</span></span> <span data-ttu-id="08e58-271">Non Gen 0 come per i piccoli oggetti.</span><span class="sxs-lookup"><span data-stu-id="08e58-271">Not Gen 0 as for small objects.</span></span> <span data-ttu-id="08e58-272">Le conseguenze sono che se si esaurisce la memoria in LOH, GC pulisce l'intero heap gestito, non solo LOH.</span><span class="sxs-lookup"><span data-stu-id="08e58-272">The consequences are that if you run out of memory in LOH, GC cleans up the whole managed heap, not only LOH.</span></span> <span data-ttu-id="08e58-273">Quindi pulisce Gen 0, Gen 1 e Gen 2, incluso LOH.</span><span class="sxs-lookup"><span data-stu-id="08e58-273">So it cleans up Gen 0, Gen 1 and Gen 2 including LOH.</span></span> <span data-ttu-id="08e58-274">Questa operazione è denominata Garbage Collection completa ed è l'operazione di Garbage Collection che richiede più tempo.</span><span class="sxs-lookup"><span data-stu-id="08e58-274">This is called full garbage collection and is the most time-consuming garbage collection.</span></span> <span data-ttu-id="08e58-275">Per molte applicazioni, può essere accettabile.</span><span class="sxs-lookup"><span data-stu-id="08e58-275">For many applications, it can be acceptable.</span></span> <span data-ttu-id="08e58-276">Ma sicuramente non per i server web ad alte prestazioni, dove sono necessari pochi buffer di memoria di grandi dimensioni per gestire una richiesta web media (lettura da un socket, decomprimere, decodificare JSON & altro ancora).</span><span class="sxs-lookup"><span data-stu-id="08e58-276">But definitely not for high-performance web servers, where few big memory buffers are needed to handle an average web request (read from a socket, decompress, decode JSON & more).</span></span>

<span data-ttu-id="08e58-277">Memorizzazione ingenua di un corpo `byte[]` di `string`richiesta o risposta di grandi dimensioni in un unico:</span><span class="sxs-lookup"><span data-stu-id="08e58-277">Naively storing a large request or response body into a single `byte[]` or `string`:</span></span>

* <span data-ttu-id="08e58-278">Può causare rapidamente lo spazio in esaurimento dello spazio nella LOH.</span><span class="sxs-lookup"><span data-stu-id="08e58-278">May result in quickly running out of space in the LOH.</span></span>
* <span data-ttu-id="08e58-279">Può causare problemi di prestazioni per l'app a causa dell'esecuzione completa dei cg.</span><span class="sxs-lookup"><span data-stu-id="08e58-279">May cause performance issues for the app because of full GCs running.</span></span>

## <a name="working-with-a-synchronous-data-processing-api"></a><span data-ttu-id="08e58-280">Utilizzo di un'API di elaborazione dati sincronaWorking with a synchronous data processing API</span><span class="sxs-lookup"><span data-stu-id="08e58-280">Working with a synchronous data processing API</span></span>

<span data-ttu-id="08e58-281">Quando si usa un serializzatore/deserializzatore che supporta solo letture e scritture sincrone (ad esempio, [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)):</span><span class="sxs-lookup"><span data-stu-id="08e58-281">When using a serializer/de-serializer that only supports synchronous reads and writes (for example,  [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)):</span></span>

* <span data-ttu-id="08e58-282">Memorizzare i dati nel buffer in memoria in modo asincrono prima di passarne nel serializzatore/deserializzatore.</span><span class="sxs-lookup"><span data-stu-id="08e58-282">Buffer the data into memory asynchronously before passing it into the serializer/de-serializer.</span></span>

> [!WARNING]
> <span data-ttu-id="08e58-283">Se la richiesta è di grandi dimensioni, potrebbe causare una condizione di memoria insufficiente (OOM).</span><span class="sxs-lookup"><span data-stu-id="08e58-283">If the request is large, it could lead to an out of memory (OOM) condition.</span></span> <span data-ttu-id="08e58-284">OOM può comportare una negazione del servizio.</span><span class="sxs-lookup"><span data-stu-id="08e58-284">OOM can result in a Denial Of Service.</span></span>  <span data-ttu-id="08e58-285">Per altre informazioni, vedere Evitare di [leggere corpi di richiesta di grandi dimensioni o corpi di risposta in memoria](#arlb) in questo documento.</span><span class="sxs-lookup"><span data-stu-id="08e58-285">For more information, see [Avoid reading large request bodies or response bodies into memory](#arlb) in this document.</span></span>

<span data-ttu-id="08e58-286">ASP.NET Core 3.0 usa <xref:System.Text.Json> per impostazione predefinita per la serializzazione JSON.</span><span class="sxs-lookup"><span data-stu-id="08e58-286">ASP.NET Core 3.0 uses <xref:System.Text.Json> by default for JSON serialization.</span></span> <span data-ttu-id="08e58-287"><xref:System.Text.Json>:</span><span class="sxs-lookup"><span data-stu-id="08e58-287"><xref:System.Text.Json>:</span></span>

* <span data-ttu-id="08e58-288">Legge e scrive JSON in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="08e58-288">Reads and writes JSON asynchronously.</span></span>
* <span data-ttu-id="08e58-289">È ottimizzato per il testo UTF-8.</span><span class="sxs-lookup"><span data-stu-id="08e58-289">Is optimized for UTF-8 text.</span></span>
* <span data-ttu-id="08e58-290">Prestazioni in `Newtonsoft.Json`genere superiori a quelle di .</span><span class="sxs-lookup"><span data-stu-id="08e58-290">Typically higher performance than `Newtonsoft.Json`.</span></span>

## <a name="do-not-store-ihttpcontextaccessorhttpcontext-in-a-field"></a><span data-ttu-id="08e58-291">Non archiviare IHttpContextAccessor.HttpContext in un campoDo not store IHttpContextAccessor.HttpContext in a field</span><span class="sxs-lookup"><span data-stu-id="08e58-291">Do not store IHttpContextAccessor.HttpContext in a field</span></span>

<span data-ttu-id="08e58-292">[Il IHttpContextAccessor.HttpContext](xref:Microsoft.AspNetCore.Http.IHttpContextAccessor.HttpContext) `HttpContext` restituisce l'oggetto della richiesta attiva quando si accede dal thread di richiesta.</span><span class="sxs-lookup"><span data-stu-id="08e58-292">The [IHttpContextAccessor.HttpContext](xref:Microsoft.AspNetCore.Http.IHttpContextAccessor.HttpContext) returns the `HttpContext` of the active request when accessed from the request thread.</span></span> <span data-ttu-id="08e58-293">L'oggetto `IHttpContextAccessor.HttpContext` **non** deve essere archiviato in un campo o in una variabile.</span><span class="sxs-lookup"><span data-stu-id="08e58-293">The `IHttpContextAccessor.HttpContext` should **not** be stored in a field or variable.</span></span>

<span data-ttu-id="08e58-294">**Non eseguire questa operazione:** Nell'esempio seguente `HttpContext` l'oggetto viene archiviato in un campo e quindi si tenta di utilizzarlo in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="08e58-294">**Do not do this:** The following example stores the `HttpContext` in a field and then attempts to use it later.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet1)]

<span data-ttu-id="08e58-295">Il codice precedente acquisisce spesso `HttpContext` un valore null o errato nel costruttore.</span><span class="sxs-lookup"><span data-stu-id="08e58-295">The preceding code frequently captures a null or incorrect `HttpContext` in the constructor.</span></span>

<span data-ttu-id="08e58-296">**Procedere come segue:** L'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="08e58-296">**Do this:** The following example:</span></span>

* <span data-ttu-id="08e58-297">Memorizza <xref:Microsoft.AspNetCore.Http.IHttpContextAccessor> l'oggetto in un campo.</span><span class="sxs-lookup"><span data-stu-id="08e58-297">Stores the <xref:Microsoft.AspNetCore.Http.IHttpContextAccessor> in a field.</span></span>
* <span data-ttu-id="08e58-298">Utilizza `HttpContext` il campo all'ora `null`corretta e verifica la presenza di .</span><span class="sxs-lookup"><span data-stu-id="08e58-298">Uses the `HttpContext` field at the correct time and checks for `null`.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet2)]

## <a name="do-not-access-httpcontext-from-multiple-threads"></a><span data-ttu-id="08e58-299">Non accedere a HttpContext da più threadDo not access HttpContext from multiple threads</span><span class="sxs-lookup"><span data-stu-id="08e58-299">Do not access HttpContext from multiple threads</span></span>

<span data-ttu-id="08e58-300">`HttpContext`*NON* è thread-safe.</span><span class="sxs-lookup"><span data-stu-id="08e58-300">`HttpContext` is *NOT* thread-safe.</span></span> <span data-ttu-id="08e58-301">L'accesso `HttpContext` da più thread in parallelo può causare un comportamento indefinito, ad esempio blocchi, arresti anomali e danneggiamento dei dati.</span><span class="sxs-lookup"><span data-stu-id="08e58-301">Accessing `HttpContext` from multiple threads in parallel can result in undefined behavior such as hangs, crashes, and data corruption.</span></span>

<span data-ttu-id="08e58-302">**Non eseguire questa operazione:** Nell'esempio seguente vengono effettuate tre richieste parallele e viene eseguito il log del percorso della richiesta in ingresso prima e dopo la richiesta HTTP in uscita.</span><span class="sxs-lookup"><span data-stu-id="08e58-302">**Do not do this:** The following example makes three parallel requests and logs the incoming request path before and after the outgoing HTTP request.</span></span> <span data-ttu-id="08e58-303">Il percorso della richiesta è accessibile da più thread, potenzialmente in parallelo.</span><span class="sxs-lookup"><span data-stu-id="08e58-303">The request path is accessed from multiple threads, potentially in parallel.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet1&highlight=25,28)]

<span data-ttu-id="08e58-304">**Procedere come segue:** Nell'esempio seguente vengono copiati tutti i dati dalla richiesta in ingresso prima di effettuare le tre richieste parallele.</span><span class="sxs-lookup"><span data-stu-id="08e58-304">**Do this:** The following example copies all data from the incoming request before making the three parallel requests.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet2&highlight=6,8,22,28)]

## <a name="do-not-use-the-httpcontext-after-the-request-is-complete"></a><span data-ttu-id="08e58-305">Non utilizzare HttpContext al termine della richiesta</span><span class="sxs-lookup"><span data-stu-id="08e58-305">Do not use the HttpContext after the request is complete</span></span>

<span data-ttu-id="08e58-306">`HttpContext`è valido solo se è presente una richiesta HTTP attiva nella pipeline di ASP.NET Core.Is only valid as there is an active HTTP request in the ASP.NET Core pipeline.</span><span class="sxs-lookup"><span data-stu-id="08e58-306">`HttpContext` is only valid as long as there is an active HTTP request in the ASP.NET Core pipeline.</span></span> <span data-ttu-id="08e58-307">L'intera pipeline ASP.NET Core è una catena asincrona di delegati che esegue ogni richiesta.</span><span class="sxs-lookup"><span data-stu-id="08e58-307">The entire ASP.NET Core pipeline is an asynchronous chain of delegates that executes every request.</span></span> <span data-ttu-id="08e58-308">Quando `Task` il ritorno da questa catena `HttpContext` viene completato, il viene riciclato.</span><span class="sxs-lookup"><span data-stu-id="08e58-308">When the `Task` returned from this chain completes, the `HttpContext` is recycled.</span></span>

<span data-ttu-id="08e58-309">**Non eseguire questa operazione:** Nell'esempio `async void` seguente viene utilizzato il quale `await` la richiesta HTTP viene completata quando viene raggiunta la prima:</span><span class="sxs-lookup"><span data-stu-id="08e58-309">**Do not do this:** The following example uses `async void` which makes the HTTP request complete when the first `await` is reached:</span></span>

* <span data-ttu-id="08e58-310">Che è **SEMPRE** una cattiva pratica nelle app ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="08e58-310">Which is **ALWAYS** a bad practice in ASP.NET Core apps.</span></span>
* <span data-ttu-id="08e58-311">Accede a `HttpResponse` dopo il completamento della richiesta HTTP.</span><span class="sxs-lookup"><span data-stu-id="08e58-311">Accesses the `HttpResponse` after the HTTP request is complete.</span></span>
* <span data-ttu-id="08e58-312">Il processo si blocca.</span><span class="sxs-lookup"><span data-stu-id="08e58-312">Crashes the process.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncBadVoidController.cs?name=snippet1)]

<span data-ttu-id="08e58-313">**Procedere come segue:** Nell'esempio seguente `Task` viene restituito un al framework, in modo che la richiesta HTTP non venga completata fino al completamento dell'azione.</span><span class="sxs-lookup"><span data-stu-id="08e58-313">**Do this:** The following example returns a `Task` to the framework, so the HTTP request doesn't complete until the action completes.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncSecondController.cs?name=snippet1)]

## <a name="do-not-capture-the-httpcontext-in-background-threads"></a><span data-ttu-id="08e58-314">Non acquisire HttpContext in thread in background</span><span class="sxs-lookup"><span data-stu-id="08e58-314">Do not capture the HttpContext in background threads</span></span>

<span data-ttu-id="08e58-315">**Non eseguire questa operazione:** Nell'esempio `Controller` seguente viene illustrato `HttpContext` una chiusura sta catturando il dalla proprietà .</span><span class="sxs-lookup"><span data-stu-id="08e58-315">**Do not do this:** The following example shows a closure is capturing the `HttpContext` from the `Controller` property.</span></span> <span data-ttu-id="08e58-316">Si tratta di una procedura non valida perché l'elemento di lavoro potrebbe:This is a bad practice because the work item could:</span><span class="sxs-lookup"><span data-stu-id="08e58-316">This is a bad practice because the work item could:</span></span>

* <span data-ttu-id="08e58-317">Eseguire all'esterno dell'ambito della richiesta.</span><span class="sxs-lookup"><span data-stu-id="08e58-317">Run outside of the request scope.</span></span>
* <span data-ttu-id="08e58-318">Tentare di `HttpContext`leggere il file .</span><span class="sxs-lookup"><span data-stu-id="08e58-318">Attempt to read the wrong `HttpContext`.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet1)]

<span data-ttu-id="08e58-319">**Procedere come segue:** L'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="08e58-319">**Do this:** The following example:</span></span>

* <span data-ttu-id="08e58-320">Copia i dati necessari nell'attività in background durante la richiesta.</span><span class="sxs-lookup"><span data-stu-id="08e58-320">Copies the data required in the background task during the request.</span></span>
* <span data-ttu-id="08e58-321">Non fa riferimento a nulla dal controller.</span><span class="sxs-lookup"><span data-stu-id="08e58-321">Doesn't reference anything from the controller.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet2)]

<span data-ttu-id="08e58-322">Le attività in background devono essere implementate come servizi ospitati.</span><span class="sxs-lookup"><span data-stu-id="08e58-322">Background tasks should be implemented as hosted services.</span></span> <span data-ttu-id="08e58-323">Per altre informazioni, vedere [Attività in background con servizi ospitati](xref:fundamentals/host/hosted-services).</span><span class="sxs-lookup"><span data-stu-id="08e58-323">For more information, see [Background tasks with hosted services](xref:fundamentals/host/hosted-services).</span></span>

## <a name="do-not-capture-services-injected-into-the-controllers-on-background-threads"></a><span data-ttu-id="08e58-324">Non acquisire servizi inseriti nei controller in thread in background</span><span class="sxs-lookup"><span data-stu-id="08e58-324">Do not capture services injected into the controllers on background threads</span></span>

<span data-ttu-id="08e58-325">**Non eseguire questa operazione:** L'esempio seguente mostra che `DbContext` una `Controller` chiusura acquisisce l'oggetto dal parametro action.</span><span class="sxs-lookup"><span data-stu-id="08e58-325">**Do not do this:** The following example shows a closure is capturing the `DbContext` from the `Controller` action parameter.</span></span> <span data-ttu-id="08e58-326">Questa è una cattiva pratica.</span><span class="sxs-lookup"><span data-stu-id="08e58-326">This is a bad practice.</span></span>  <span data-ttu-id="08e58-327">L'elemento di lavoro può essere eseguito all'esterno dell'ambito della richiesta.</span><span class="sxs-lookup"><span data-stu-id="08e58-327">The work item could run outside of the request scope.</span></span> <span data-ttu-id="08e58-328">L'ambito `ContosoDbContext` dell'oggetto è la `ObjectDisposedException`richiesta, generando un oggetto .</span><span class="sxs-lookup"><span data-stu-id="08e58-328">The `ContosoDbContext` is scoped to the request, resulting in an `ObjectDisposedException`.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet1)]

<span data-ttu-id="08e58-329">**Procedere come segue:** L'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="08e58-329">**Do this:** The following example:</span></span>

* <span data-ttu-id="08e58-330">Inserisce <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory> un in ordine per creare un ambito nell'elemento di lavoro in background.</span><span class="sxs-lookup"><span data-stu-id="08e58-330">Injects an <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory> in order to create a scope in the background work item.</span></span> <span data-ttu-id="08e58-331">`IServiceScopeFactory`è un singleton.</span><span class="sxs-lookup"><span data-stu-id="08e58-331">`IServiceScopeFactory` is a singleton.</span></span>
* <span data-ttu-id="08e58-332">Crea un nuovo ambito di inserimento delle dipendenze nel thread in background.</span><span class="sxs-lookup"><span data-stu-id="08e58-332">Creates a new dependency injection scope in the background thread.</span></span>
* <span data-ttu-id="08e58-333">Non fa riferimento a nulla dal controller.</span><span class="sxs-lookup"><span data-stu-id="08e58-333">Doesn't reference anything from the controller.</span></span>
* <span data-ttu-id="08e58-334">Non acquisisce `ContosoDbContext` il dalla richiesta in ingresso.</span><span class="sxs-lookup"><span data-stu-id="08e58-334">Doesn't capture the `ContosoDbContext` from the incoming request.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2)]

<span data-ttu-id="08e58-335">Il seguente codice evidenziato:</span><span class="sxs-lookup"><span data-stu-id="08e58-335">The following highlighted code:</span></span>

* <span data-ttu-id="08e58-336">Crea un ambito per la durata dell'operazione in background e risolve i servizi da essa.</span><span class="sxs-lookup"><span data-stu-id="08e58-336">Creates a scope for the lifetime of the background operation and resolves services from it.</span></span>
* <span data-ttu-id="08e58-337">Utilizza `ContosoDbContext` dall'ambito corretto.</span><span class="sxs-lookup"><span data-stu-id="08e58-337">Uses `ContosoDbContext` from the correct scope.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2&highlight=9-16)]

## <a name="do-not-modify-the-status-code-or-headers-after-the-response-body-has-started"></a><span data-ttu-id="08e58-338">Non modificare il codice di stato o le intestazioni dopo l'avvio del corpo della risposta</span><span class="sxs-lookup"><span data-stu-id="08e58-338">Do not modify the status code or headers after the response body has started</span></span>

<span data-ttu-id="08e58-339">ASP.NET Core non memorizza nel buffer il corpo della risposta HTTP.</span><span class="sxs-lookup"><span data-stu-id="08e58-339">ASP.NET Core does not buffer the HTTP response body.</span></span> <span data-ttu-id="08e58-340">La prima volta che viene scritta la risposta:</span><span class="sxs-lookup"><span data-stu-id="08e58-340">The first time the response is written:</span></span>

* <span data-ttu-id="08e58-341">Le intestazioni vengono inviate insieme a tale blocco di corpo al client.</span><span class="sxs-lookup"><span data-stu-id="08e58-341">The headers are sent along with that chunk of the body to the client.</span></span>
* <span data-ttu-id="08e58-342">Non è più possibile modificare le intestazioni di risposta.</span><span class="sxs-lookup"><span data-stu-id="08e58-342">It's no longer possible to change response headers.</span></span>

<span data-ttu-id="08e58-343">**Non eseguire questa operazione:** Il codice seguente tenta di aggiungere intestazioni di risposta dopo che la risposta è già stata avviata:The following code tries to add response headers after the response has already started:</span><span class="sxs-lookup"><span data-stu-id="08e58-343">**Do not do this:** The following code tries to add response headers after the response has already started:</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet1)]

<span data-ttu-id="08e58-344">Nel codice precedente, `context.Response.Headers["test"] = "test value";` genererà un'eccezione se `next()` ha scritto nella risposta.</span><span class="sxs-lookup"><span data-stu-id="08e58-344">In the preceding code, `context.Response.Headers["test"] = "test value";` will throw an exception if `next()` has written to the response.</span></span>

<span data-ttu-id="08e58-345">**Procedere come segue:** Nell'esempio seguente viene verificato se la risposta HTTP è stata avviata prima di modificare le intestazioni.</span><span class="sxs-lookup"><span data-stu-id="08e58-345">**Do this:** The following example checks if the HTTP response has started before modifying the headers.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet2)]

<span data-ttu-id="08e58-346">**Procedere come segue:** Nell'esempio `HttpResponse.OnStarting` seguente viene utilizzato per impostare le intestazioni prima che le intestazioni di risposta vengano scaricate nel client.</span><span class="sxs-lookup"><span data-stu-id="08e58-346">**Do this:** The following example uses `HttpResponse.OnStarting` to set the headers before the response headers are flushed to the client.</span></span>

<span data-ttu-id="08e58-347">Il controllo se la risposta non è stata avviata consente la registrazione di un callback che verrà richiamato subito prima della scrittura delle intestazioni di risposta.</span><span class="sxs-lookup"><span data-stu-id="08e58-347">Checking if the response has not started allows registering a callback that will be invoked just before response headers are written.</span></span> <span data-ttu-id="08e58-348">Verifica se la risposta non è iniziata:</span><span class="sxs-lookup"><span data-stu-id="08e58-348">Checking if the response has not started:</span></span>

* <span data-ttu-id="08e58-349">Consente di aggiungere o sostituire le intestazioni just in time.</span><span class="sxs-lookup"><span data-stu-id="08e58-349">Provides the ability to append or override headers just in time.</span></span>
* <span data-ttu-id="08e58-350">Non richiede la conoscenza del middleware successivo nella pipeline.</span><span class="sxs-lookup"><span data-stu-id="08e58-350">Doesn't require knowledge of the next middleware in the pipeline.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet3)]

## <a name="do-not-call-next-if-you-have-already-started-writing-to-the-response-body"></a><span data-ttu-id="08e58-351">Non chiamare next() se hai già iniziato a scrivere nel corpo della risposta</span><span class="sxs-lookup"><span data-stu-id="08e58-351">Do not call next() if you have already started writing to the response body</span></span>

<span data-ttu-id="08e58-352">I componenti prevedono di essere chiamati solo se è possibile per loro gestire e modificare la risposta.</span><span class="sxs-lookup"><span data-stu-id="08e58-352">Components only expect to be called if it's possible for them to handle and manipulate the response.</span></span>
